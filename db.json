{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"source/images/2019/01/29/87df2510-231e-11e9-b1b0-9fe5cd51c268.png","path":"images/2019/01/29/87df2510-231e-11e9-b1b0-9fe5cd51c268.png","modified":0,"renderable":0},{"_id":"source/images/2019/01/29/8fbba060-231e-11e9-b1b0-9fe5cd51c268.png","path":"images/2019/01/29/8fbba060-231e-11e9-b1b0-9fe5cd51c268.png","modified":0,"renderable":0},{"_id":"source/images/2019/01/29/90c2fe40-231e-11e9-b1b0-9fe5cd51c268.png","path":"images/2019/01/29/90c2fe40-231e-11e9-b1b0-9fe5cd51c268.png","modified":0,"renderable":0},{"_id":"source/images/2019/01/29/91d64300-231e-11e9-b1b0-9fe5cd51c268.png","path":"images/2019/01/29/91d64300-231e-11e9-b1b0-9fe5cd51c268.png","modified":0,"renderable":0},{"_id":"source/images/2019/01/29/92592ea0-231e-11e9-b1b0-9fe5cd51c268.png","path":"images/2019/01/29/92592ea0-231e-11e9-b1b0-9fe5cd51c268.png","modified":0,"renderable":0},{"_id":"source/images/2019/01/29/93329eb0-231e-11e9-b1b0-9fe5cd51c268.png","path":"images/2019/01/29/93329eb0-231e-11e9-b1b0-9fe5cd51c268.png","modified":0,"renderable":0},{"_id":"source/images/2019/01/29/9419ca60-231e-11e9-b1b0-9fe5cd51c268.png","path":"images/2019/01/29/9419ca60-231e-11e9-b1b0-9fe5cd51c268.png","modified":0,"renderable":0},{"_id":"source/images/2019/01/29/95611770-231e-11e9-b1b0-9fe5cd51c268.png","path":"images/2019/01/29/95611770-231e-11e9-b1b0-9fe5cd51c268.png","modified":0,"renderable":0},{"_id":"source/images/2019/01/29/b217dc50-231e-11e9-b1b0-9fe5cd51c268.png","path":"images/2019/01/29/b217dc50-231e-11e9-b1b0-9fe5cd51c268.png","modified":0,"renderable":0},{"_id":"source/images/2019/02/12/358e2940-2e19-11e9-9f9c-ad7650439f74.png","path":"images/2019/02/12/358e2940-2e19-11e9-9f9c-ad7650439f74.png","modified":0,"renderable":0},{"_id":"source/images/2019/10/02/4258a230-e4d6-11e9-be0a-25abc0bfd9b1.png","path":"images/2019/10/02/4258a230-e4d6-11e9-be0a-25abc0bfd9b1.png","modified":0,"renderable":0},{"_id":"source/images/2019/10/02/6d672000-e4d6-11e9-be0a-25abc0bfd9b1.png","path":"images/2019/10/02/6d672000-e4d6-11e9-be0a-25abc0bfd9b1.png","modified":0,"renderable":0},{"_id":"source/images/2019/10/02/90a715f0-e4ba-11e9-be0a-25abc0bfd9b1.png","path":"images/2019/10/02/90a715f0-e4ba-11e9-be0a-25abc0bfd9b1.png","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"source/images/2019/04/06/4d97ca40-581d-11e9-b771-0953c0a9891c.png","path":"images/2019/04/06/4d97ca40-581d-11e9-b771-0953c0a9891c.png","modified":0,"renderable":0},{"_id":"source/images/2019/04/06/4e5770c0-581d-11e9-b771-0953c0a9891c.png","path":"images/2019/04/06/4e5770c0-581d-11e9-b771-0953c0a9891c.png","modified":0,"renderable":0},{"_id":"source/images/2019/04/06/4e69e980-582c-11e9-b771-0953c0a9891c.png","path":"images/2019/04/06/4e69e980-582c-11e9-b771-0953c0a9891c.png","modified":0,"renderable":0},{"_id":"source/images/2019/04/06/7b7dee90-581c-11e9-b771-0953c0a9891c.png","path":"images/2019/04/06/7b7dee90-581c-11e9-b771-0953c0a9891c.png","modified":0,"renderable":0},{"_id":"source/images/2019/10/06/d7548980-e7fb-11e9-a821-27322da6d155.png","path":"images/2019/10/06/d7548980-e7fb-11e9-a821-27322da6d155.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"source/images/2019/04/06/f7a416a0-581e-11e9-b771-0953c0a9891c.png","path":"images/2019/04/06/f7a416a0-581e-11e9-b771-0953c0a9891c.png","modified":0,"renderable":0},{"_id":"source/images/2019/10/02/579c0870-e4c3-11e9-be0a-25abc0bfd9b1.png","path":"images/2019/10/02/579c0870-e4c3-11e9-be0a-25abc0bfd9b1.png","modified":0,"renderable":0},{"_id":"source/images/2019/10/06/f14693a0-e7fc-11e9-a821-27322da6d155.png","path":"images/2019/10/06/f14693a0-e7fc-11e9-a821-27322da6d155.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"source/images/2019/04/06/7b3a3960-581d-11e9-b771-0953c0a9891c.png","path":"images/2019/04/06/7b3a3960-581d-11e9-b771-0953c0a9891c.png","modified":0,"renderable":0},{"_id":"source/images/2019/10/06/13aeabe0-e7fc-11e9-a821-27322da6d155.png","path":"images/2019/10/06/13aeabe0-e7fc-11e9-a821-27322da6d155.png","modified":0,"renderable":0},{"_id":"source/images/2019/10/06/6b34ad60-e7fc-11e9-a821-27322da6d155.png","path":"images/2019/10/06/6b34ad60-e7fc-11e9-a821-27322da6d155.png","modified":0,"renderable":0},{"_id":"source/images/2019/04/06/35a25370-581c-11e9-b771-0953c0a9891c.png","path":"images/2019/04/06/35a25370-581c-11e9-b771-0953c0a9891c.png","modified":0,"renderable":0},{"_id":"source/images/2019/10/06/dca4bf30-e7fc-11e9-a821-27322da6d155.png","path":"images/2019/10/06/dca4bf30-e7fc-11e9-a821-27322da6d155.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"5708ee3c6a064b615183f0c60f5b04fdfcdb2588","modified":1548217864000},{"_id":"themes/next/.DS_Store","hash":"18bd17536c432c700a024a2da3ec2251821f2d35","modified":1548077248000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1548065672000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1548065672000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1548065672000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1548065672000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1548065672000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1548065672000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1548065672000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1548065672000},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1548065672000},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1548065672000},{"_id":"themes/next/_config.yml","hash":"62e4e712b159466f8d80f8dcf535db67caa5dd0c","modified":1548214806000},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1548065672000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1548065672000},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1548065672000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1548217834000},{"_id":"source/_posts/DP经典之终结背包问题.md","hash":"374a4c26d6cc2afb935bec46544ba034afd847b2","modified":1554536918000},{"_id":"source/_posts/Java刷题错题以及收集的Java零碎知识。.md","hash":"b84a61cea2a2d6eb25b106b7b1dbb0ad4a0faf91","modified":1553838868000},{"_id":"source/_posts/Java核心技术学习笔记.md","hash":"07c5ce447a5ed2c5fdd3fcdc6eefd98c6f5eede1","modified":1568894436000},{"_id":"source/_posts/MySql两阶段加锁（2PL）协议剖析.md","hash":"8df3fa62e80fb162c4fcfe9a9b2b5d988d433ef5","modified":1553838918000},{"_id":"source/_posts/avatar.gif","hash":"a71106a3e9cd419461e71d58deba0af9b2ae4f61","modified":1548074270000},{"_id":"source/_posts/siddhi源码.md","hash":"65e3086cdfec45b0a339aa2eb5ddb7956a53c934","modified":1569982372000},{"_id":"source/_posts/转-make-2-1-tee-log-txt命令解析.md","hash":"0d52e0ce614ad5abf6b999cfb59f84f2cd1b0a6c","modified":1553838906000},{"_id":"source/_posts/转-基于-Token-的身份验证：JSON-Web-Token.md","hash":"122619f8bf257873e216f8acbb8c1b02928d79c5","modified":1548235352000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1548065672000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1548065672000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1548065672000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1548065672000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1548065672000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1548065672000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1548065672000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1548065672000},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1548065672000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1548065672000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1548065672000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1548065672000},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1548065672000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1548065672000},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1548065672000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1548065672000},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1548065672000},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1548065672000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1548065672000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1548065672000},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1548065672000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1548065672000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1548065672000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1548065672000},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1548065672000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1548065672000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1548065672000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1548065672000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1548065672000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548065672000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1548065672000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1548065672000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1548065672000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1548065672000},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1548065672000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1548065672000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1548065672000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1548065672000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1548065672000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1548065672000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1548065672000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1548065672000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1548065672000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1548065672000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1548065672000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1548065672000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1548065672000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1548065672000},{"_id":"themes/next/layout/_third-party/.DS_Store","hash":"701539ae58d5d5066f665dafb7aa9fe0e47164fc","modified":1566813062000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1548065672000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1548065672000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1548065672000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1548065672000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1548065672000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1548065672000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1548065672000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1548065672000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1548065672000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1548065672000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1548065672000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1548065672000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1548065672000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1548065672000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1548065672000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1548065672000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1548065672000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1548065672000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1548065672000},{"_id":"themes/next/source/images/avatar.gif","hash":"a71106a3e9cd419461e71d58deba0af9b2ae4f61","modified":1548074270000},{"_id":"themes/next/source/images/avatar.jpeg","hash":"cb617728fa9c4d3f9e81094dd2fc449426c2fff9","modified":1548074992000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1548065672000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1548065672000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1548065672000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1548065672000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1548065672000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1548065672000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1548065672000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1548065672000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1548065672000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1548065672000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1548065672000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1548065672000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1548065672000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1548065672000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1548065672000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548065672000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548065672000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548065672000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548065672000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548065672000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548065672000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548065672000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1548065672000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1548065672000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1548065672000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1548065672000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1548065672000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1548065672000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1548065672000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1548065672000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1548065672000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1548065672000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1548065672000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1548065672000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1548065672000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1548065672000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1548065672000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1548065672000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1548065672000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1548065672000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1548065672000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1548065672000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1548065672000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1548065672000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1548065672000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1548065672000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1548065672000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1548065672000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1548065672000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1548065672000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1548065672000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1548065672000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1548065672000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1548065672000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1548065672000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1548065672000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1548065672000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1548065672000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1548065672000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1548065672000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1548065672000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1548065672000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1548065672000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1548065672000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1548065672000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1548065672000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1548065672000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1548065672000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1548065672000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1548065672000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1548065672000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1548065672000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1548065672000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1548065672000},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1548065672000},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1548084570000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1548065672000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1548065672000},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1548065672000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1548065672000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1548065672000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1548065672000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1548065672000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1548065672000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1548065672000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1548065672000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1548065672000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1548065672000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1548065672000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1548065672000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1548065672000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1548065672000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1548065672000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1548065672000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1548065672000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1548065672000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1548065672000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1548065672000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1548065672000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1548065672000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1548065672000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1548065672000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1548065672000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1548065672000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1548065672000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1548065672000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1548065672000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1548065672000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1548065672000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1548065672000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1548065672000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1548065672000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1548065672000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1548065672000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1548065672000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1548065672000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1548065672000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1548065672000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1548065672000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1548065672000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1548065672000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1548065672000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1548065672000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1548065672000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1548065672000},{"_id":"source/images/2019/01/29/87df2510-231e-11e9-b1b0-9fe5cd51c268.png","hash":"f47d641a049acc7c6322b54b132e480618bb34b0","modified":1548694964000},{"_id":"source/images/2019/01/29/8fbba060-231e-11e9-b1b0-9fe5cd51c268.png","hash":"f47d641a049acc7c6322b54b132e480618bb34b0","modified":1548694976000},{"_id":"source/images/2019/01/29/90c2fe40-231e-11e9-b1b0-9fe5cd51c268.png","hash":"f47d641a049acc7c6322b54b132e480618bb34b0","modified":1548694978000},{"_id":"source/images/2019/01/29/91d64300-231e-11e9-b1b0-9fe5cd51c268.png","hash":"f47d641a049acc7c6322b54b132e480618bb34b0","modified":1548694980000},{"_id":"source/images/2019/01/29/92592ea0-231e-11e9-b1b0-9fe5cd51c268.png","hash":"f47d641a049acc7c6322b54b132e480618bb34b0","modified":1548694982000},{"_id":"source/images/2019/01/29/93329eb0-231e-11e9-b1b0-9fe5cd51c268.png","hash":"f47d641a049acc7c6322b54b132e480618bb34b0","modified":1548694982000},{"_id":"source/images/2019/01/29/9419ca60-231e-11e9-b1b0-9fe5cd51c268.png","hash":"f47d641a049acc7c6322b54b132e480618bb34b0","modified":1548694984000},{"_id":"source/images/2019/01/29/95611770-231e-11e9-b1b0-9fe5cd51c268.png","hash":"f47d641a049acc7c6322b54b132e480618bb34b0","modified":1548694986000},{"_id":"source/images/2019/01/29/b217dc50-231e-11e9-b1b0-9fe5cd51c268.png","hash":"ad86c1d2d44a10fcc4714ad1468a6fc30d567792","modified":1548695034000},{"_id":"source/images/2019/02/12/358e2940-2e19-11e9-9f9c-ad7650439f74.png","hash":"f3145aa0c578d2247ea39990cf2c22373cb4d9bc","modified":1549902140000},{"_id":"source/images/2019/10/02/4258a230-e4d6-11e9-be0a-25abc0bfd9b1.png","hash":"6c2acd1a5441769de5b08446a6feefb4bbd39755","modified":1569994448000},{"_id":"source/images/2019/10/02/6d672000-e4d6-11e9-be0a-25abc0bfd9b1.png","hash":"657e1d86d009a3ca3fae9ac36e4dbfbfed1d1c74","modified":1569994522000},{"_id":"source/images/2019/10/02/90a715f0-e4ba-11e9-be0a-25abc0bfd9b1.png","hash":"353f2c0d817fdf26dcc98c6825c5b4e4126ce3e2","modified":1569982554000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1548065672000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1548065672000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1548065672000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1548065672000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1548065672000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1548065672000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1548065672000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1548065672000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1548065672000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1548065672000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1548065672000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1548065672000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1548065672000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1548065672000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1548065672000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1548065672000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1548065672000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1548065672000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1548065672000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1548065672000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1548065672000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1548065672000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1548065672000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1548065672000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1548065672000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1548065672000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1548065672000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1548065672000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1548065672000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1548065672000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1548065672000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1548065672000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1548065672000},{"_id":"source/images/2019/04/06/4d97ca40-581d-11e9-b771-0953c0a9891c.png","hash":"4483f1ad9d07031fe4d5201e3fe2f6bb49cba4db","modified":1554521848000},{"_id":"source/images/2019/04/06/4e5770c0-581d-11e9-b771-0953c0a9891c.png","hash":"4483f1ad9d07031fe4d5201e3fe2f6bb49cba4db","modified":1554521850000},{"_id":"source/images/2019/04/06/4e69e980-582c-11e9-b771-0953c0a9891c.png","hash":"3df0e945f46e1a9161b8ff00d1eb235d82f0f612","modified":1554528292000},{"_id":"source/images/2019/04/06/7b7dee90-581c-11e9-b771-0953c0a9891c.png","hash":"7d9146d71aef2c8049037231c2e197c1268c205b","modified":1554521496000},{"_id":"source/images/2019/10/06/d7548980-e7fb-11e9-a821-27322da6d155.png","hash":"4785e05c81d8031a5509154a499a1a7617674017","modified":1570340444000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1548065672000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1548065672000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1548065672000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1548065672000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1548065672000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1548065672000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1548065672000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1548065672000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1548065672000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1548065672000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1548065672000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1548065672000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1548065672000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1548065672000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1548065672000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1548065672000},{"_id":"source/images/2019/04/06/f7a416a0-581e-11e9-b771-0953c0a9891c.png","hash":"1bf70fe1d103a71db460c6a7eced3b5eb9a9425e","modified":1554533196000},{"_id":"source/images/2019/10/02/579c0870-e4c3-11e9-be0a-25abc0bfd9b1.png","hash":"4f47ad4ca0f5f764a7429b6c02689df16afa8f5c","modified":1569986324000},{"_id":"source/images/2019/10/06/f14693a0-e7fc-11e9-a821-27322da6d155.png","hash":"1e966a618d42b1385a645b566ac4ed9bbe4c53a0","modified":1570340916000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1548065672000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1548065672000},{"_id":"source/images/2019/04/06/7b3a3960-581d-11e9-b771-0953c0a9891c.png","hash":"5648dc9c8defb1fbb77c89110a5709aa18436606","modified":1554521924000},{"_id":"source/images/2019/10/06/13aeabe0-e7fc-11e9-a821-27322da6d155.png","hash":"5bc130770a4ec997e4b57588af741b6943be64f3","modified":1570340544000},{"_id":"source/images/2019/10/06/6b34ad60-e7fc-11e9-a821-27322da6d155.png","hash":"b3778af56936e7fb6320ab0e79c21238ca33ddbb","modified":1570340692000},{"_id":"source/images/2019/04/06/35a25370-581c-11e9-b771-0953c0a9891c.png","hash":"e7147421901223b55a19a4e8f60229c7973ba950","modified":1554521378000},{"_id":"source/images/2019/10/06/dca4bf30-e7fc-11e9-a821-27322da6d155.png","hash":"1382d3e8a4dde22b0d0f86ee3be7eb504324149b","modified":1570340882000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1548065672000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1548065672000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1548065672000},{"_id":"public/CNAME","hash":"9c5edb8a1965af83b58facceb2cab29fba4a5fa6","modified":1571807260746},{"_id":"public/2019/10/02/siddhi源码/index.html","hash":"21342b61ad6dd075f48361957c6b80f065302d32","modified":1571807260758},{"_id":"public/2019/01/23/转-基于-Token-的身份验证：JSON-Web-Token/index.html","hash":"c676f362d028493a471d3baa280fb4591e1bb458","modified":1571807260758},{"_id":"public/archives/index.html","hash":"99fd30e8566f5977a67c68080302ef556a32cc19","modified":1571807260758},{"_id":"public/archives/2019/index.html","hash":"4db251192b82107af93c3318958d529be65e30fe","modified":1571807260758},{"_id":"public/archives/2019/01/index.html","hash":"791cb53c85f4bd9559bd72c2e414d3327f5dd6fc","modified":1571807260758},{"_id":"public/archives/2019/02/index.html","hash":"d251efe28d3c8291e900146248314f0fa7199864","modified":1571807260759},{"_id":"public/archives/2019/03/index.html","hash":"6ef6cd31f871c3391373e626c97b0be046cd2952","modified":1571807260759},{"_id":"public/archives/2019/10/index.html","hash":"d5bde832ddb52b93c6d9b603143fa0aee781975c","modified":1571807260759},{"_id":"public/categories/算法/index.html","hash":"b3a092b541479483ed01a1f681a991265e7ba385","modified":1571807260759},{"_id":"public/categories/Java/index.html","hash":"13f1e8b8b75f88a35172ae38129c7f5792002665","modified":1571807260759},{"_id":"public/categories/数据库/index.html","hash":"2cf0a22f84528fa7e8f772437ea6bb985b04bfec","modified":1571807260759},{"_id":"public/categories/Linux/index.html","hash":"1af27b65c20a420e5f869ab4ca3116b0ff162663","modified":1571807260759},{"_id":"public/categories/Web/index.html","hash":"48fe35a96438c0da0956b579cf4004a97a7ca95f","modified":1571807260759},{"_id":"public/categories/数据库/并发/index.html","hash":"06d1a30f778e5bf3b3c6d63a6b5c4841504f3d64","modified":1571807260759},{"_id":"public/categories/Web/安全/index.html","hash":"a4e1fdb6811b4118c09aa07ee7a8d336bb1325e6","modified":1571807260759},{"_id":"public/tags/笔记/index.html","hash":"7ffbd0ee89a94e1dfbc97ba87d7a1844dbd7b8d2","modified":1571807260759},{"_id":"public/tags/算法/index.html","hash":"b2c1ab725f9da24636f2f59e4f225ff84d2e9e72","modified":1571807260759},{"_id":"public/tags/动态规划/index.html","hash":"d697630aaedbe04d4c4865cee95c6e53f7678628","modified":1571807260759},{"_id":"public/tags/语言/index.html","hash":"cb9f0ed7034b98382c0a16a6f98292814f2396c6","modified":1571807260759},{"_id":"public/tags/基础/index.html","hash":"a5826cad92ae6261723081d9970f6cba70081683","modified":1571807260759},{"_id":"public/tags/Java/index.html","hash":"46a574864eb66b87b5ff29351b8fc420284616a9","modified":1571807260759},{"_id":"public/tags/数据库/index.html","hash":"2d96eec8cd52bd29495c24343403fd98c570e2a0","modified":1571807260759},{"_id":"public/tags/MySQL/index.html","hash":"616009953fd3674b726a163bf02b53f60e4d6144","modified":1571807260759},{"_id":"public/tags/并发/index.html","hash":"7e95c843e80b7d469c399e810fb3e350d1b7ee76","modified":1571807260759},{"_id":"public/tags/Linux/index.html","hash":"c09425f9a785eff80a6e225b3d254822b14ce24c","modified":1571807260759},{"_id":"public/tags/Web/index.html","hash":"730ba37c80afa959be3dfce45ac22656bad6427b","modified":1571807260759},{"_id":"public/tags/安全/index.html","hash":"ba9882932e6518bfafce20171e903edaa9c68ef4","modified":1571807260759},{"_id":"public/2019/03/29/DP经典之终结背包问题/index.html","hash":"725fde45710a71f0381692109b7aa721ca6c0f80","modified":1571807260759},{"_id":"public/2019/02/27/MySql两阶段加锁（2PL）协议剖析/index.html","hash":"3fb77d3a0b10e783ff1c281944db6053c421f082","modified":1571807260759},{"_id":"public/2019/01/25/转-make-2-1-tee-log-txt命令解析/index.html","hash":"73b3f5c9e9c9c14586a7e75b7a58fc5747e1c007","modified":1571807260759},{"_id":"public/2019/01/22/Java刷题错题以及收集的Java零碎知识。/index.html","hash":"c0ad51215cfa402abdc09b69e8448549470e07f0","modified":1571807260759},{"_id":"public/2019/01/21/Java核心技术学习笔记/index.html","hash":"44723dc3fc62cdccab12b74d78dcf12d4f5852c9","modified":1571807260759},{"_id":"public/index.html","hash":"3003d5738b4e37a31fb70f24c8fe38ae062e941c","modified":1571807260759},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1571807260765},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1571807260765},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1571807260765},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1571807260765},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1571807260765},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1571807260765},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1571807260765},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1571807260765},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1571807260765},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1571807260765},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1571807260765},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1571807260765},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1571807260765},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1571807260765},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1571807260765},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1571807260765},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1571807260765},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1571807260765},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1571807260765},{"_id":"public/images/2019/01/29/87df2510-231e-11e9-b1b0-9fe5cd51c268.png","hash":"f47d641a049acc7c6322b54b132e480618bb34b0","modified":1571807260765},{"_id":"public/images/2019/01/29/91d64300-231e-11e9-b1b0-9fe5cd51c268.png","hash":"f47d641a049acc7c6322b54b132e480618bb34b0","modified":1571807260766},{"_id":"public/images/2019/01/29/92592ea0-231e-11e9-b1b0-9fe5cd51c268.png","hash":"f47d641a049acc7c6322b54b132e480618bb34b0","modified":1571807260766},{"_id":"public/images/2019/01/29/8fbba060-231e-11e9-b1b0-9fe5cd51c268.png","hash":"f47d641a049acc7c6322b54b132e480618bb34b0","modified":1571807260766},{"_id":"public/images/2019/01/29/93329eb0-231e-11e9-b1b0-9fe5cd51c268.png","hash":"f47d641a049acc7c6322b54b132e480618bb34b0","modified":1571807260766},{"_id":"public/images/2019/01/29/90c2fe40-231e-11e9-b1b0-9fe5cd51c268.png","hash":"f47d641a049acc7c6322b54b132e480618bb34b0","modified":1571807260766},{"_id":"public/images/2019/01/29/b217dc50-231e-11e9-b1b0-9fe5cd51c268.png","hash":"ad86c1d2d44a10fcc4714ad1468a6fc30d567792","modified":1571807260766},{"_id":"public/images/2019/01/29/9419ca60-231e-11e9-b1b0-9fe5cd51c268.png","hash":"f47d641a049acc7c6322b54b132e480618bb34b0","modified":1571807260766},{"_id":"public/images/2019/01/29/95611770-231e-11e9-b1b0-9fe5cd51c268.png","hash":"f47d641a049acc7c6322b54b132e480618bb34b0","modified":1571807260766},{"_id":"public/images/2019/10/02/4258a230-e4d6-11e9-be0a-25abc0bfd9b1.png","hash":"6c2acd1a5441769de5b08446a6feefb4bbd39755","modified":1571807260766},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1571807260766},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1571807260766},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1571807260766},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1571807260766},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1571807260766},{"_id":"public/images/2019/02/12/358e2940-2e19-11e9-9f9c-ad7650439f74.png","hash":"f3145aa0c578d2247ea39990cf2c22373cb4d9bc","modified":1571807260766},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1571807260766},{"_id":"public/images/2019/10/02/6d672000-e4d6-11e9-be0a-25abc0bfd9b1.png","hash":"657e1d86d009a3ca3fae9ac36e4dbfbfed1d1c74","modified":1571807260766},{"_id":"public/images/2019/10/02/90a715f0-e4ba-11e9-be0a-25abc0bfd9b1.png","hash":"353f2c0d817fdf26dcc98c6825c5b4e4126ce3e2","modified":1571807260766},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1571807260766},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1571807260766},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1571807260766},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1571807260766},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1571807260766},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1571807260766},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1571807260766},{"_id":"public/images/avatar.gif","hash":"a71106a3e9cd419461e71d58deba0af9b2ae4f61","modified":1571807261057},{"_id":"public/images/avatar.jpeg","hash":"cb617728fa9c4d3f9e81094dd2fc449426c2fff9","modified":1571807261060},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1571807261065},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1571807261065},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1571807261071},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1571807261071},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1571807261072},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1571807261072},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1571807261072},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1571807261072},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1571807261072},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1571807261072},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1571807261072},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1571807261072},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1571807261072},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1571807261072},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1571807261072},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1571807261072},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1571807261072},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1571807261072},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1571807261072},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1571807261072},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1571807261072},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1571807261072},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1571807261072},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1571807261072},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1571807261072},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1571807261072},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1571807261072},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1571807261072},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1571807261072},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1571807261072},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1571807261072},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1571807261072},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1571807261072},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1571807261072},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1571807261072},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1571807261072},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1571807261072},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1571807261073},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1571807261073},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1571807261073},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1571807261073},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1571807261073},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1571807261073},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1571807261073},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1571807261073},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1571807261073},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1571807261073},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1571807261073},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1571807261073},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1571807261073},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1571807261073},{"_id":"public/css/main.css","hash":"3d9768fc610d57527971dad7220bf4e8e8597a32","modified":1571807261073},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1571807261073},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1571807261073},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1571807261073},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1571807261073},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1571807261073},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1571807261073},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1571807261073},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1571807261073},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1571807261073},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1571807261073},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1571807261073},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1571807261073},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1571807261073},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1571807261073},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1571807261073},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1571807261074},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1571807261074},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1571807261074},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1571807261074},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1571807261074},{"_id":"public/images/2019/04/06/4d97ca40-581d-11e9-b771-0953c0a9891c.png","hash":"4483f1ad9d07031fe4d5201e3fe2f6bb49cba4db","modified":1571807261074},{"_id":"public/images/2019/04/06/4e69e980-582c-11e9-b771-0953c0a9891c.png","hash":"3df0e945f46e1a9161b8ff00d1eb235d82f0f612","modified":1571807261074},{"_id":"public/images/2019/04/06/f7a416a0-581e-11e9-b771-0953c0a9891c.png","hash":"1bf70fe1d103a71db460c6a7eced3b5eb9a9425e","modified":1571807261074},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1571807261074},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1571807261074},{"_id":"public/images/2019/10/06/d7548980-e7fb-11e9-a821-27322da6d155.png","hash":"4785e05c81d8031a5509154a499a1a7617674017","modified":1571807261078},{"_id":"public/images/2019/10/02/579c0870-e4c3-11e9-be0a-25abc0bfd9b1.png","hash":"4f47ad4ca0f5f764a7429b6c02689df16afa8f5c","modified":1571807261078},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1571807261078},{"_id":"public/images/2019/10/06/6b34ad60-e7fc-11e9-a821-27322da6d155.png","hash":"b3778af56936e7fb6320ab0e79c21238ca33ddbb","modified":1571807261078},{"_id":"public/images/2019/10/06/dca4bf30-e7fc-11e9-a821-27322da6d155.png","hash":"1382d3e8a4dde22b0d0f86ee3be7eb504324149b","modified":1571807261078},{"_id":"public/images/2019/04/06/7b7dee90-581c-11e9-b771-0953c0a9891c.png","hash":"7d9146d71aef2c8049037231c2e197c1268c205b","modified":1571807261082},{"_id":"public/images/2019/04/06/4e5770c0-581d-11e9-b771-0953c0a9891c.png","hash":"4483f1ad9d07031fe4d5201e3fe2f6bb49cba4db","modified":1571807261084},{"_id":"public/images/2019/10/06/f14693a0-e7fc-11e9-a821-27322da6d155.png","hash":"1e966a618d42b1385a645b566ac4ed9bbe4c53a0","modified":1571807261084},{"_id":"public/images/2019/10/06/13aeabe0-e7fc-11e9-a821-27322da6d155.png","hash":"5bc130770a4ec997e4b57588af741b6943be64f3","modified":1571807261084},{"_id":"public/images/2019/04/06/7b3a3960-581d-11e9-b771-0953c0a9891c.png","hash":"5648dc9c8defb1fbb77c89110a5709aa18436606","modified":1571807261084},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1571807261090},{"_id":"public/images/2019/04/06/35a25370-581c-11e9-b771-0953c0a9891c.png","hash":"e7147421901223b55a19a4e8f60229c7973ba950","modified":1571807261090}],"Category":[{"name":"算法","_id":"ck22tga3v0002wureh4fxqu0n"},{"name":"Java","_id":"ck22tga3z0007wure7iph3s92"},{"name":"数据库","_id":"ck22tga43000ewurebqxhd04u"},{"name":"Linux","_id":"ck22tga44000kwurejmlpbtic"},{"name":"Web","_id":"ck22tga45000nwure2hibahu0"},{"name":"并发","parent":"ck22tga43000ewurebqxhd04u","_id":"ck22tga45000qwurepvxf8dxw"},{"name":"安全","parent":"ck22tga45000nwure2hibahu0","_id":"ck22tga46000swure1w0wmtg4"}],"Data":[],"Page":[],"Post":[{"title":"DP经典之终结背包问题","originContent":"# DP经典之终结背包问题\n\n前两天刷题一道完全背包问题，无论如何都超时，百思不得其解。查了之后才知道有一维数组的解决方法。现来总结一下基本的背包问题。\n<!-- more -->\n### 01背包\n#### 状态转移方程：\n`f[i][j] = max(f[i - 1][j] , f[i - 1][j - weight[i]] + value[i]) `\n> i为物品范围（列），j为背包重量（行）\nn个物品，m空间\n\n#### 举例如何分析转移方程：\n其一，我们发现列扫描（j固定，i变化）只能从小到大。原因是我们所求值（f（i,j））所在位置的列值(j)和需要用到的数据列值**有相同**且为前置数据（f(i-1,j)），故必然只能从小到大。\n\n其二，行扫描（i固定，j变化）则无所谓。原因是我们所求值（f（i,j））所在位置的行值(i)和需要用到的数据列值**都不同**，故当前行扫描无论以何种顺序都是正确的。\n\n其三，由于行扫描只需要扫描前一行的数据，最多只需要当前行和上一行，故实际上不需要简历f[n][m]数组，只需要f[2][m]即可，i-1之前的状态不需要要记忆。\n\n其四，进一步的来讲，不难想到，可以通过适当的扫描顺序来重复利用一行数据达到仅使用一位数组的目的。即将行扫描倒序进行。此时的倒序进行不是转移方程所要求的，而是优化技巧而已。\n#### 代码\n```C++\nfor (int i = 1; i <= n; i++) {\n    for (int j = m; j >= weight[i]; j--) {\n         f[j] = f[j] > f[j - weight[i]] + value[i] ? f[j] : f[j - weight[i]] + value[i];\n    }\n}\n```\n### 完全背包\n#### 复杂状态转移方程：\n`f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<=v}`\n时间复杂度：O(V*Σ(V/c[i]))\n#### 化简状态转移方程：\n`f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}`\n时间复杂度：O(VN)\n> i为物品范围（列），v为背包重量（行）\n#### 为何可以这样化简？\n简要说明：\n>完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v=0..V的顺序循环。这就是这个简单的程序为何成立的道理。\n——背包九讲\n#### 代码\n```C++\n    for (int i = 1; i <= n; i++) {\n        for (int j = weight[i]; j <= m; j++) {\n            f[j] = max(f[j], f[j - weight[i]] + value[i]);\n        }\n    }\n```\n### 多重背包\n#### 题目：\n有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最·大。\n#### 状态转移方程\n`f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k<=n[i]}`\n时间复杂度：O(V*Σn[i])\n#### 转化为01背包问题\n将多个物品相同物品转化为单个不同物品，通过二进制的思想进项转化。\n> 考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。\n\n>方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1>0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。\n#### 伪代码（二进制分解法）\n```Python\nprocedure MultiplePack(cost,weight,amount)\n    if cost*amount>=V\n        CompletePack(cost,weight)\n        return\n    integer k=1\n    while k<amount\n        ZeroOnePack(k*cost,k*weight)\n        amount=amount-k\n        k=k*2\n    ZeroOnePack(amount*cost,amount*weight)\n```\n#### 代码（非二进制分解法实现）\n```C++\n#include <iostream>\nusing namespace std;\n#define V 1000\nint weight[50 + 1];\nint value[50 + 1];\nint num[20 + 1];\nint f[V + 1];\nint max(int a, int b) {\n    return a > b ? a : b;\n}\nint main() {\n    int n, m;\n    cout << \"请输入物品个数:\";\n    cin >> n;\n    cout << \"请分别输入\" << n << \"个物品的重量、价值和数量:\" << endl; \n    for (int i = 1; i <= n; i++) {\n        cin >> weight[i] >> value[i] >> num[i];\n    }\n    int k = n + 1;\n    for (int i = 1; i <= n; i++) {\n        while (num[i] != 1) {\n            weight[k] = weight[i];\n            value[k] = value[i];\n            k++;\n            num[i]--;\n        }\n    }\n    cout << \"请输入背包容量:\";\n    cin >> m;\n    for (int i = 1; i <= k; i++) {\n        for (int j = m; j >= 1; j--) {\n            if (weight[i] <= j) f[j] = max(f[j], f[j - weight[i]] + value[i]);\n        }\n    }\n    cout << \"背包能放的最大价值为:\" << f[m] << endl;\n}\n```\n#### 代码（二进制分解法实现）\n//todo\n#### O(VN)算法的存在\n> 多重背包问题同样有O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。\n\n### 混合三种背包问题\n#### 01背包与完全背包的混合\n##### 伪代码\n```python\nfor i=1..N\n    if 第i件物品属于01背包\n        for v=V..0\n            f[v]=max{f[v],f[v-c[i]]+w[i]};\n    else if 第i件物品属于完全背包\n        for v=0..V\n            f[v]=max{f[v],f[v-c[i]]+w[i]};\n```\n#### 再加上多重背包\n##### 伪代码\n```python\nfor i=1..N\n    if 第i件物品属于01背包\n        ZeroOnePack(c[i],w[i])\n    else if 第i件物品属于完全背包\n        CompletePack(c[i],w[i])\n    else if 第i件物品属于多重背包\n        MultiplePack(c[i],w[i],n[i])\n```\n参考资料\n[背包问题九讲](https://www.kancloud.cn/kancloud/pack/70129)\n[背包问题：0-1背包、完全背包和多重背包](https://www.cnblogs.com/fengziwei/p/7750849.html)","toc":true,"date":"2019-03-29T08:22:37.000Z","_content":"\n# DP经典之终结背包问题\n\n前两天刷题一道完全背包问题，无论如何都超时，百思不得其解。查了之后才知道有一维数组的解决方法。现来总结一下基本的背包问题。\n<!-- more --> \n### 01背包\n#### 状态转移方程：\n`f[i][j] = max(f[i - 1][j] , f[i - 1][j - weight[i]] + value[i]) `\n> i为物品范围（列），j为背包重量（行）\nn个物品，m空间\n\n#### 举例如何分析转移方程：\n其一，我们发现列扫描（j固定，i变化）只能从小到大。原因是我们所求值（f（i,j））所在位置的列值(j)和需要用到的数据列值**有相同**且为前置数据（f(i-1,j)），故必然只能从小到大。\n\n其二，行扫描（i固定，j变化）则无所谓。原因是我们所求值（f（i,j））所在位置的行值(i)和需要用到的数据列值**都不同**，故当前行扫描无论以何种顺序都是正确的。\n\n其三，由于行扫描只需要扫描前一行的数据，最多只需要当前行和上一行，故实际上不需要简历f[n][m]数组，只需要f[2][m]即可，i-1之前的状态不需要要记忆。\n\n其四，进一步的来讲，不难想到，可以通过适当的扫描顺序来重复利用一行数据达到仅使用一位数组的目的。即将行扫描倒序进行。此时的倒序进行不是转移方程所要求的，而是优化技巧而已。\n#### 代码\n```C++\nfor (int i = 1; i <= n; i++) {\n    for (int j = m; j >= weight[i]; j--) {\n         f[j] = f[j] > f[j - weight[i]] + value[i] ? f[j] : f[j - weight[i]] + value[i];\n    }\n}\n```\n### 完全背包\n#### 复杂状态转移方程：\n`f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<=v}`\n时间复杂度：O(V*Σ(V/c[i]))\n#### 化简状态转移方程：\n`f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}`\n时间复杂度：O(VN)\n> i为物品范围（列），v为背包重量（行）\n#### 为何可以这样化简？\n简要说明：\n>完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v=0..V的顺序循环。这就是这个简单的程序为何成立的道理。\n——背包九讲\n#### 代码\n```C++\n    for (int i = 1; i <= n; i++) {\n        for (int j = weight[i]; j <= m; j++) {\n            f[j] = max(f[j], f[j - weight[i]] + value[i]);\n        }\n    }\n```\n### 多重背包\n#### 题目：\n有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最·大。\n#### 状态转移方程\n`f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k<=n[i]}`\n时间复杂度：O(V*Σn[i])\n#### 转化为01背包问题\n将多个物品相同物品转化为单个不同物品，通过二进制的思想进项转化。\n> 考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。\n\n>方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1>0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。\n#### 伪代码（二进制分解法）\n```Python\nprocedure MultiplePack(cost,weight,amount)\n    if cost*amount>=V\n        CompletePack(cost,weight)\n        return\n    integer k=1\n    while k<amount\n        ZeroOnePack(k*cost,k*weight)\n        amount=amount-k\n        k=k*2\n    ZeroOnePack(amount*cost,amount*weight)\n```\n#### 代码（非二进制分解法实现）\n```C++\n#include <iostream>\nusing namespace std;\n#define V 1000\nint weight[50 + 1];\nint value[50 + 1];\nint num[20 + 1];\nint f[V + 1];\nint max(int a, int b) {\n    return a > b ? a : b;\n}\nint main() {\n    int n, m;\n    cout << \"请输入物品个数:\";\n    cin >> n;\n    cout << \"请分别输入\" << n << \"个物品的重量、价值和数量:\" << endl; \n    for (int i = 1; i <= n; i++) {\n        cin >> weight[i] >> value[i] >> num[i];\n    }\n    int k = n + 1;\n    for (int i = 1; i <= n; i++) {\n        while (num[i] != 1) {\n            weight[k] = weight[i];\n            value[k] = value[i];\n            k++;\n            num[i]--;\n        }\n    }\n    cout << \"请输入背包容量:\";\n    cin >> m;\n    for (int i = 1; i <= k; i++) {\n        for (int j = m; j >= 1; j--) {\n            if (weight[i] <= j) f[j] = max(f[j], f[j - weight[i]] + value[i]);\n        }\n    }\n    cout << \"背包能放的最大价值为:\" << f[m] << endl;\n}\n```\n#### 代码（二进制分解法实现）\n//todo\n#### O(VN)算法的存在\n> 多重背包问题同样有O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。\n\n### 混合三种背包问题\n#### 01背包与完全背包的混合\n##### 伪代码\n```python\nfor i=1..N\n    if 第i件物品属于01背包\n        for v=V..0\n            f[v]=max{f[v],f[v-c[i]]+w[i]};\n    else if 第i件物品属于完全背包\n        for v=0..V\n            f[v]=max{f[v],f[v-c[i]]+w[i]};\n```\n#### 再加上多重背包\n##### 伪代码\n```python\nfor i=1..N\n    if 第i件物品属于01背包\n        ZeroOnePack(c[i],w[i])\n    else if 第i件物品属于完全背包\n        CompletePack(c[i],w[i])\n    else if 第i件物品属于多重背包\n        MultiplePack(c[i],w[i],n[i])\n```\n参考资料\n[背包问题九讲](https://www.kancloud.cn/kancloud/pack/70129)\n[背包问题：0-1背包、完全背包和多重背包](https://www.cnblogs.com/fengziwei/p/7750849.html)","source":"_posts/DP经典之终结背包问题.md","raw":"---\ntitle: DP经典之终结背包问题\ntags:\n  - 笔记\n  - 算法\n  - 动态规划\noriginContent: >-\n  # DP经典之终结背包问题\n\n\n  前两天刷题一道完全背包问题，无论如何都超时，百思不得其解。查了之后才知道有一维数组的解决方法。现来总结一下基本的背包问题。\n\n  <!-- more -->\n\n  ### 01背包\n\n  #### 状态转移方程：\n\n  `f[i][j] = max(f[i - 1][j] , f[i - 1][j - weight[i]] + value[i]) `\n\n  > i为物品范围（列），j为背包重量（行）\n\n  n个物品，m空间\n\n\n  #### 举例如何分析转移方程：\n\n  其一，我们发现列扫描（j固定，i变化）只能从小到大。原因是我们所求值（f（i,j））所在位置的列值(j)和需要用到的数据列值**有相同**且为前置数据（f(i-1,j)），故必然只能从小到大。\n\n\n  其二，行扫描（i固定，j变化）则无所谓。原因是我们所求值（f（i,j））所在位置的行值(i)和需要用到的数据列值**都不同**，故当前行扫描无论以何种顺序都是正确的。\n\n\n  其三，由于行扫描只需要扫描前一行的数据，最多只需要当前行和上一行，故实际上不需要简历f[n][m]数组，只需要f[2][m]即可，i-1之前的状态不需要要记忆。\n\n\n  其四，进一步的来讲，不难想到，可以通过适当的扫描顺序来重复利用一行数据达到仅使用一位数组的目的。即将行扫描倒序进行。此时的倒序进行不是转移方程所要求的，而是优化技巧而已。\n\n  #### 代码\n\n  ```C++\n\n  for (int i = 1; i <= n; i++) {\n      for (int j = m; j >= weight[i]; j--) {\n           f[j] = f[j] > f[j - weight[i]] + value[i] ? f[j] : f[j - weight[i]] + value[i];\n      }\n  }\n\n  ```\n\n  ### 完全背包\n\n  #### 复杂状态转移方程：\n\n  `f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<=v}`\n\n  时间复杂度：O(V*Σ(V/c[i]))\n\n  #### 化简状态转移方程：\n\n  `f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}`\n\n  时间复杂度：O(VN)\n\n  > i为物品范围（列），v为背包重量（行）\n\n  #### 为何可以这样化简？\n\n  简要说明：\n\n  >完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v=0..V的顺序循环。这就是这个简单的程序为何成立的道理。\n\n  ——背包九讲\n\n  #### 代码\n\n  ```C++\n      for (int i = 1; i <= n; i++) {\n          for (int j = weight[i]; j <= m; j++) {\n              f[j] = max(f[j], f[j - weight[i]] + value[i]);\n          }\n      }\n  ```\n\n  ### 多重背包\n\n  #### 题目：\n\n  有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最·大。\n\n  #### 状态转移方程\n\n  `f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k<=n[i]}`\n\n  时间复杂度：O(V*Σn[i])\n\n  #### 转化为01背包问题\n\n  将多个物品相同物品转化为单个不同物品，通过二进制的思想进项转化。\n\n  >\n  考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。\n\n\n  >方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1>0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。\n\n  #### 伪代码（二进制分解法）\n\n  ```Python\n\n  procedure MultiplePack(cost,weight,amount)\n      if cost*amount>=V\n          CompletePack(cost,weight)\n          return\n      integer k=1\n      while k<amount\n          ZeroOnePack(k*cost,k*weight)\n          amount=amount-k\n          k=k*2\n      ZeroOnePack(amount*cost,amount*weight)\n  ```\n\n  #### 代码（非二进制分解法实现）\n\n  ```C++\n\n  #include <iostream>\n\n  using namespace std;\n\n  #define V 1000\n\n  int weight[50 + 1];\n\n  int value[50 + 1];\n\n  int num[20 + 1];\n\n  int f[V + 1];\n\n  int max(int a, int b) {\n      return a > b ? a : b;\n  }\n\n  int main() {\n      int n, m;\n      cout << \"请输入物品个数:\";\n      cin >> n;\n      cout << \"请分别输入\" << n << \"个物品的重量、价值和数量:\" << endl; \n      for (int i = 1; i <= n; i++) {\n          cin >> weight[i] >> value[i] >> num[i];\n      }\n      int k = n + 1;\n      for (int i = 1; i <= n; i++) {\n          while (num[i] != 1) {\n              weight[k] = weight[i];\n              value[k] = value[i];\n              k++;\n              num[i]--;\n          }\n      }\n      cout << \"请输入背包容量:\";\n      cin >> m;\n      for (int i = 1; i <= k; i++) {\n          for (int j = m; j >= 1; j--) {\n              if (weight[i] <= j) f[j] = max(f[j], f[j - weight[i]] + value[i]);\n          }\n      }\n      cout << \"背包能放的最大价值为:\" << f[m] << endl;\n  }\n\n  ```\n\n  #### 代码（二进制分解法实现）\n\n  //todo\n\n  #### O(VN)算法的存在\n\n  >\n  多重背包问题同样有O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。\n\n\n  ### 混合三种背包问题\n\n  #### 01背包与完全背包的混合\n\n  ##### 伪代码\n\n  ```python\n\n  for i=1..N\n      if 第i件物品属于01背包\n          for v=V..0\n              f[v]=max{f[v],f[v-c[i]]+w[i]};\n      else if 第i件物品属于完全背包\n          for v=0..V\n              f[v]=max{f[v],f[v-c[i]]+w[i]};\n  ```\n\n  #### 再加上多重背包\n\n  ##### 伪代码\n\n  ```python\n\n  for i=1..N\n      if 第i件物品属于01背包\n          ZeroOnePack(c[i],w[i])\n      else if 第i件物品属于完全背包\n          CompletePack(c[i],w[i])\n      else if 第i件物品属于多重背包\n          MultiplePack(c[i],w[i],n[i])\n  ```\n\n  参考资料\n\n  [背包问题九讲](https://www.kancloud.cn/kancloud/pack/70129)\n\n  [背包问题：0-1背包、完全背包和多重背包](https://www.cnblogs.com/fengziwei/p/7750849.html)\ncategories:\n  - 算法\ntoc: true\ndate: 2019-03-29 16:22:37\n---\n\n# DP经典之终结背包问题\n\n前两天刷题一道完全背包问题，无论如何都超时，百思不得其解。查了之后才知道有一维数组的解决方法。现来总结一下基本的背包问题。\n<!-- more --> \n### 01背包\n#### 状态转移方程：\n`f[i][j] = max(f[i - 1][j] , f[i - 1][j - weight[i]] + value[i]) `\n> i为物品范围（列），j为背包重量（行）\nn个物品，m空间\n\n#### 举例如何分析转移方程：\n其一，我们发现列扫描（j固定，i变化）只能从小到大。原因是我们所求值（f（i,j））所在位置的列值(j)和需要用到的数据列值**有相同**且为前置数据（f(i-1,j)），故必然只能从小到大。\n\n其二，行扫描（i固定，j变化）则无所谓。原因是我们所求值（f（i,j））所在位置的行值(i)和需要用到的数据列值**都不同**，故当前行扫描无论以何种顺序都是正确的。\n\n其三，由于行扫描只需要扫描前一行的数据，最多只需要当前行和上一行，故实际上不需要简历f[n][m]数组，只需要f[2][m]即可，i-1之前的状态不需要要记忆。\n\n其四，进一步的来讲，不难想到，可以通过适当的扫描顺序来重复利用一行数据达到仅使用一位数组的目的。即将行扫描倒序进行。此时的倒序进行不是转移方程所要求的，而是优化技巧而已。\n#### 代码\n```C++\nfor (int i = 1; i <= n; i++) {\n    for (int j = m; j >= weight[i]; j--) {\n         f[j] = f[j] > f[j - weight[i]] + value[i] ? f[j] : f[j - weight[i]] + value[i];\n    }\n}\n```\n### 完全背包\n#### 复杂状态转移方程：\n`f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<=v}`\n时间复杂度：O(V*Σ(V/c[i]))\n#### 化简状态转移方程：\n`f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}`\n时间复杂度：O(VN)\n> i为物品范围（列），v为背包重量（行）\n#### 为何可以这样化简？\n简要说明：\n>完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v=0..V的顺序循环。这就是这个简单的程序为何成立的道理。\n——背包九讲\n#### 代码\n```C++\n    for (int i = 1; i <= n; i++) {\n        for (int j = weight[i]; j <= m; j++) {\n            f[j] = max(f[j], f[j - weight[i]] + value[i]);\n        }\n    }\n```\n### 多重背包\n#### 题目：\n有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最·大。\n#### 状态转移方程\n`f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k<=n[i]}`\n时间复杂度：O(V*Σn[i])\n#### 转化为01背包问题\n将多个物品相同物品转化为单个不同物品，通过二进制的思想进项转化。\n> 考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。\n\n>方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1>0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。\n#### 伪代码（二进制分解法）\n```Python\nprocedure MultiplePack(cost,weight,amount)\n    if cost*amount>=V\n        CompletePack(cost,weight)\n        return\n    integer k=1\n    while k<amount\n        ZeroOnePack(k*cost,k*weight)\n        amount=amount-k\n        k=k*2\n    ZeroOnePack(amount*cost,amount*weight)\n```\n#### 代码（非二进制分解法实现）\n```C++\n#include <iostream>\nusing namespace std;\n#define V 1000\nint weight[50 + 1];\nint value[50 + 1];\nint num[20 + 1];\nint f[V + 1];\nint max(int a, int b) {\n    return a > b ? a : b;\n}\nint main() {\n    int n, m;\n    cout << \"请输入物品个数:\";\n    cin >> n;\n    cout << \"请分别输入\" << n << \"个物品的重量、价值和数量:\" << endl; \n    for (int i = 1; i <= n; i++) {\n        cin >> weight[i] >> value[i] >> num[i];\n    }\n    int k = n + 1;\n    for (int i = 1; i <= n; i++) {\n        while (num[i] != 1) {\n            weight[k] = weight[i];\n            value[k] = value[i];\n            k++;\n            num[i]--;\n        }\n    }\n    cout << \"请输入背包容量:\";\n    cin >> m;\n    for (int i = 1; i <= k; i++) {\n        for (int j = m; j >= 1; j--) {\n            if (weight[i] <= j) f[j] = max(f[j], f[j - weight[i]] + value[i]);\n        }\n    }\n    cout << \"背包能放的最大价值为:\" << f[m] << endl;\n}\n```\n#### 代码（二进制分解法实现）\n//todo\n#### O(VN)算法的存在\n> 多重背包问题同样有O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。\n\n### 混合三种背包问题\n#### 01背包与完全背包的混合\n##### 伪代码\n```python\nfor i=1..N\n    if 第i件物品属于01背包\n        for v=V..0\n            f[v]=max{f[v],f[v-c[i]]+w[i]};\n    else if 第i件物品属于完全背包\n        for v=0..V\n            f[v]=max{f[v],f[v-c[i]]+w[i]};\n```\n#### 再加上多重背包\n##### 伪代码\n```python\nfor i=1..N\n    if 第i件物品属于01背包\n        ZeroOnePack(c[i],w[i])\n    else if 第i件物品属于完全背包\n        CompletePack(c[i],w[i])\n    else if 第i件物品属于多重背包\n        MultiplePack(c[i],w[i],n[i])\n```\n参考资料\n[背包问题九讲](https://www.kancloud.cn/kancloud/pack/70129)\n[背包问题：0-1背包、完全背包和多重背包](https://www.cnblogs.com/fengziwei/p/7750849.html)","slug":"DP经典之终结背包问题","published":1,"updated":"2019-04-06T07:48:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22tga3q0000wurep415xqcn","content":"<h1 id=\"DP经典之终结背包问题\"><a href=\"#DP经典之终结背包问题\" class=\"headerlink\" title=\"DP经典之终结背包问题\"></a>DP经典之终结背包问题</h1><p>前两天刷题一道完全背包问题，无论如何都超时，百思不得其解。查了之后才知道有一维数组的解决方法。现来总结一下基本的背包问题。<br><a id=\"more\"></a> </p>\n<h3 id=\"01背包\"><a href=\"#01背包\" class=\"headerlink\" title=\"01背包\"></a>01背包</h3><h4 id=\"状态转移方程：\"><a href=\"#状态转移方程：\" class=\"headerlink\" title=\"状态转移方程：\"></a>状态转移方程：</h4><p><code>f[i][j] = max(f[i - 1][j] , f[i - 1][j - weight[i]] + value[i])</code></p>\n<blockquote>\n<p>i为物品范围（列），j为背包重量（行）<br>n个物品，m空间</p>\n</blockquote>\n<h4 id=\"举例如何分析转移方程：\"><a href=\"#举例如何分析转移方程：\" class=\"headerlink\" title=\"举例如何分析转移方程：\"></a>举例如何分析转移方程：</h4><p>其一，我们发现列扫描（j固定，i变化）只能从小到大。原因是我们所求值（f（i,j））所在位置的列值(j)和需要用到的数据列值<strong>有相同</strong>且为前置数据（f(i-1,j)），故必然只能从小到大。</p>\n<p>其二，行扫描（i固定，j变化）则无所谓。原因是我们所求值（f（i,j））所在位置的行值(i)和需要用到的数据列值<strong>都不同</strong>，故当前行扫描无论以何种顺序都是正确的。</p>\n<p>其三，由于行扫描只需要扫描前一行的数据，最多只需要当前行和上一行，故实际上不需要简历f[n][m]数组，只需要f[2][m]即可，i-1之前的状态不需要要记忆。</p>\n<p>其四，进一步的来讲，不难想到，可以通过适当的扫描顺序来重复利用一行数据达到仅使用一位数组的目的。即将行扫描倒序进行。此时的倒序进行不是转移方程所要求的，而是优化技巧而已。</p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = m; j &gt;= weight[i]; j--) &#123;</span><br><span class=\"line\">         f[j] = f[j] &gt; f[j - weight[i]] + value[i] ? f[j] : f[j - weight[i]] + value[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"完全背包\"><a href=\"#完全背包\" class=\"headerlink\" title=\"完全背包\"></a>完全背包</h3><h4 id=\"复杂状态转移方程：\"><a href=\"#复杂状态转移方程：\" class=\"headerlink\" title=\"复杂状态转移方程：\"></a>复杂状态转移方程：</h4><p><code>f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;=v}</code><br>时间复杂度：O(V*Σ(V/c[i]))</p>\n<h4 id=\"化简状态转移方程：\"><a href=\"#化简状态转移方程：\" class=\"headerlink\" title=\"化简状态转移方程：\"></a>化简状态转移方程：</h4><p><code>f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}</code><br>时间复杂度：O(VN)</p>\n<blockquote>\n<p>i为物品范围（列），v为背包重量（行）</p>\n</blockquote>\n<h4 id=\"为何可以这样化简？\"><a href=\"#为何可以这样化简？\" class=\"headerlink\" title=\"为何可以这样化简？\"></a>为何可以这样化简？</h4><p>简要说明：</p>\n<blockquote>\n<p>完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v=0..V的顺序循环。这就是这个简单的程序为何成立的道理。<br>——背包九讲</p>\n</blockquote>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = weight[i]; j &lt;= m; j++) &#123;</span><br><span class=\"line\">        f[j] = max(f[j], f[j - weight[i]] + value[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"多重背包\"><a href=\"#多重背包\" class=\"headerlink\" title=\"多重背包\"></a>多重背包</h3><h4 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h4><p>有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最·大。</p>\n<h4 id=\"状态转移方程\"><a href=\"#状态转移方程\" class=\"headerlink\" title=\"状态转移方程\"></a>状态转移方程</h4><p><code>f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k&lt;=n[i]}</code><br>时间复杂度：O(V*Σn[i])</p>\n<h4 id=\"转化为01背包问题\"><a href=\"#转化为01背包问题\" class=\"headerlink\" title=\"转化为01背包问题\"></a>转化为01背包问题</h4><p>将多个物品相同物品转化为单个不同物品，通过二进制的思想进项转化。</p>\n<blockquote>\n<p>考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。</p>\n</blockquote>\n<blockquote>\n<p>方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为1,2,4,…,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1&gt;0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。</p>\n</blockquote>\n<h4 id=\"伪代码（二进制分解法）\"><a href=\"#伪代码（二进制分解法）\" class=\"headerlink\" title=\"伪代码（二进制分解法）\"></a>伪代码（二进制分解法）</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">procedure MultiplePack(cost,weight,amount)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> cost*amount&gt;=V</span><br><span class=\"line\">        CompletePack(cost,weight)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    integer k=<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> k&lt;amount</span><br><span class=\"line\">        ZeroOnePack(k*cost,k*weight)</span><br><span class=\"line\">        amount=amount-k</span><br><span class=\"line\">        k=k*<span class=\"number\">2</span></span><br><span class=\"line\">    ZeroOnePack(amount*cost,amount*weight)</span><br></pre></td></tr></table></figure>\n<h4 id=\"代码（非二进制分解法实现）\"><a href=\"#代码（非二进制分解法实现）\" class=\"headerlink\" title=\"代码（非二进制分解法实现）\"></a>代码（非二进制分解法实现）</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> V 1000</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> weight[<span class=\"number\">50</span> + <span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> value[<span class=\"number\">50</span> + <span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> num[<span class=\"number\">20</span> + <span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> f[V + <span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a &gt; b ? a : b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"请输入物品个数:\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"请分别输入\"</span> &lt;&lt; n &lt;&lt; <span class=\"string\">\"个物品的重量、价值和数量:\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; weight[i] &gt;&gt; value[i] &gt;&gt; num[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = n + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (num[i] != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            weight[k] = weight[i];</span><br><span class=\"line\">            value[k] = value[i];</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">            num[i]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"请输入背包容量:\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= k; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = m; j &gt;= <span class=\"number\">1</span>; j--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (weight[i] &lt;= j) f[j] = max(f[j], f[j - weight[i]] + value[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"背包能放的最大价值为:\"</span> &lt;&lt; f[m] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"代码（二进制分解法实现）\"><a href=\"#代码（二进制分解法实现）\" class=\"headerlink\" title=\"代码（二进制分解法实现）\"></a>代码（二进制分解法实现）</h4><p>//todo</p>\n<h4 id=\"O-VN-算法的存在\"><a href=\"#O-VN-算法的存在\" class=\"headerlink\" title=\"O(VN)算法的存在\"></a>O(VN)算法的存在</h4><blockquote>\n<p>多重背包问题同样有O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。</p>\n</blockquote>\n<h3 id=\"混合三种背包问题\"><a href=\"#混合三种背包问题\" class=\"headerlink\" title=\"混合三种背包问题\"></a>混合三种背包问题</h3><h4 id=\"01背包与完全背包的混合\"><a href=\"#01背包与完全背包的混合\" class=\"headerlink\" title=\"01背包与完全背包的混合\"></a>01背包与完全背包的混合</h4><h5 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i=<span class=\"number\">1.</span>.N</span><br><span class=\"line\">    <span class=\"keyword\">if</span> 第i件物品属于<span class=\"number\">01</span>背包</span><br><span class=\"line\">        <span class=\"keyword\">for</span> v=V.<span class=\"number\">.0</span></span><br><span class=\"line\">            f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> 第i件物品属于完全背包</span><br><span class=\"line\">        <span class=\"keyword\">for</span> v=<span class=\"number\">0.</span>.V</span><br><span class=\"line\">            f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"再加上多重背包\"><a href=\"#再加上多重背包\" class=\"headerlink\" title=\"再加上多重背包\"></a>再加上多重背包</h4><h5 id=\"伪代码-1\"><a href=\"#伪代码-1\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i=<span class=\"number\">1.</span>.N</span><br><span class=\"line\">    <span class=\"keyword\">if</span> 第i件物品属于<span class=\"number\">01</span>背包</span><br><span class=\"line\">        ZeroOnePack(c[i],w[i])</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> 第i件物品属于完全背包</span><br><span class=\"line\">        CompletePack(c[i],w[i])</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> 第i件物品属于多重背包</span><br><span class=\"line\">        MultiplePack(c[i],w[i],n[i])</span><br></pre></td></tr></table></figure>\n<p>参考资料<br><a href=\"https://www.kancloud.cn/kancloud/pack/70129\" target=\"_blank\" rel=\"noopener\">背包问题九讲</a><br><a href=\"https://www.cnblogs.com/fengziwei/p/7750849.html\" target=\"_blank\" rel=\"noopener\">背包问题：0-1背包、完全背包和多重背包</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"DP经典之终结背包问题\"><a href=\"#DP经典之终结背包问题\" class=\"headerlink\" title=\"DP经典之终结背包问题\"></a>DP经典之终结背包问题</h1><p>前两天刷题一道完全背包问题，无论如何都超时，百思不得其解。查了之后才知道有一维数组的解决方法。现来总结一下基本的背包问题。<br>","more":"</p>\n<h3 id=\"01背包\"><a href=\"#01背包\" class=\"headerlink\" title=\"01背包\"></a>01背包</h3><h4 id=\"状态转移方程：\"><a href=\"#状态转移方程：\" class=\"headerlink\" title=\"状态转移方程：\"></a>状态转移方程：</h4><p><code>f[i][j] = max(f[i - 1][j] , f[i - 1][j - weight[i]] + value[i])</code></p>\n<blockquote>\n<p>i为物品范围（列），j为背包重量（行）<br>n个物品，m空间</p>\n</blockquote>\n<h4 id=\"举例如何分析转移方程：\"><a href=\"#举例如何分析转移方程：\" class=\"headerlink\" title=\"举例如何分析转移方程：\"></a>举例如何分析转移方程：</h4><p>其一，我们发现列扫描（j固定，i变化）只能从小到大。原因是我们所求值（f（i,j））所在位置的列值(j)和需要用到的数据列值<strong>有相同</strong>且为前置数据（f(i-1,j)），故必然只能从小到大。</p>\n<p>其二，行扫描（i固定，j变化）则无所谓。原因是我们所求值（f（i,j））所在位置的行值(i)和需要用到的数据列值<strong>都不同</strong>，故当前行扫描无论以何种顺序都是正确的。</p>\n<p>其三，由于行扫描只需要扫描前一行的数据，最多只需要当前行和上一行，故实际上不需要简历f[n][m]数组，只需要f[2][m]即可，i-1之前的状态不需要要记忆。</p>\n<p>其四，进一步的来讲，不难想到，可以通过适当的扫描顺序来重复利用一行数据达到仅使用一位数组的目的。即将行扫描倒序进行。此时的倒序进行不是转移方程所要求的，而是优化技巧而已。</p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = m; j &gt;= weight[i]; j--) &#123;</span><br><span class=\"line\">         f[j] = f[j] &gt; f[j - weight[i]] + value[i] ? f[j] : f[j - weight[i]] + value[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"完全背包\"><a href=\"#完全背包\" class=\"headerlink\" title=\"完全背包\"></a>完全背包</h3><h4 id=\"复杂状态转移方程：\"><a href=\"#复杂状态转移方程：\" class=\"headerlink\" title=\"复杂状态转移方程：\"></a>复杂状态转移方程：</h4><p><code>f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;=v}</code><br>时间复杂度：O(V*Σ(V/c[i]))</p>\n<h4 id=\"化简状态转移方程：\"><a href=\"#化简状态转移方程：\" class=\"headerlink\" title=\"化简状态转移方程：\"></a>化简状态转移方程：</h4><p><code>f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}</code><br>时间复杂度：O(VN)</p>\n<blockquote>\n<p>i为物品范围（列），v为背包重量（行）</p>\n</blockquote>\n<h4 id=\"为何可以这样化简？\"><a href=\"#为何可以这样化简？\" class=\"headerlink\" title=\"为何可以这样化简？\"></a>为何可以这样化简？</h4><p>简要说明：</p>\n<blockquote>\n<p>完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v=0..V的顺序循环。这就是这个简单的程序为何成立的道理。<br>——背包九讲</p>\n</blockquote>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = weight[i]; j &lt;= m; j++) &#123;</span><br><span class=\"line\">        f[j] = max(f[j], f[j - weight[i]] + value[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"多重背包\"><a href=\"#多重背包\" class=\"headerlink\" title=\"多重背包\"></a>多重背包</h3><h4 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h4><p>有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最·大。</p>\n<h4 id=\"状态转移方程\"><a href=\"#状态转移方程\" class=\"headerlink\" title=\"状态转移方程\"></a>状态转移方程</h4><p><code>f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k&lt;=n[i]}</code><br>时间复杂度：O(V*Σn[i])</p>\n<h4 id=\"转化为01背包问题\"><a href=\"#转化为01背包问题\" class=\"headerlink\" title=\"转化为01背包问题\"></a>转化为01背包问题</h4><p>将多个物品相同物品转化为单个不同物品，通过二进制的思想进项转化。</p>\n<blockquote>\n<p>考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。</p>\n</blockquote>\n<blockquote>\n<p>方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为1,2,4,…,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1&gt;0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。</p>\n</blockquote>\n<h4 id=\"伪代码（二进制分解法）\"><a href=\"#伪代码（二进制分解法）\" class=\"headerlink\" title=\"伪代码（二进制分解法）\"></a>伪代码（二进制分解法）</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">procedure MultiplePack(cost,weight,amount)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> cost*amount&gt;=V</span><br><span class=\"line\">        CompletePack(cost,weight)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    integer k=<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> k&lt;amount</span><br><span class=\"line\">        ZeroOnePack(k*cost,k*weight)</span><br><span class=\"line\">        amount=amount-k</span><br><span class=\"line\">        k=k*<span class=\"number\">2</span></span><br><span class=\"line\">    ZeroOnePack(amount*cost,amount*weight)</span><br></pre></td></tr></table></figure>\n<h4 id=\"代码（非二进制分解法实现）\"><a href=\"#代码（非二进制分解法实现）\" class=\"headerlink\" title=\"代码（非二进制分解法实现）\"></a>代码（非二进制分解法实现）</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> V 1000</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> weight[<span class=\"number\">50</span> + <span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> value[<span class=\"number\">50</span> + <span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> num[<span class=\"number\">20</span> + <span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> f[V + <span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a &gt; b ? a : b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"请输入物品个数:\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"请分别输入\"</span> &lt;&lt; n &lt;&lt; <span class=\"string\">\"个物品的重量、价值和数量:\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; weight[i] &gt;&gt; value[i] &gt;&gt; num[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = n + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (num[i] != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            weight[k] = weight[i];</span><br><span class=\"line\">            value[k] = value[i];</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">            num[i]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"请输入背包容量:\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= k; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = m; j &gt;= <span class=\"number\">1</span>; j--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (weight[i] &lt;= j) f[j] = max(f[j], f[j - weight[i]] + value[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"背包能放的最大价值为:\"</span> &lt;&lt; f[m] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"代码（二进制分解法实现）\"><a href=\"#代码（二进制分解法实现）\" class=\"headerlink\" title=\"代码（二进制分解法实现）\"></a>代码（二进制分解法实现）</h4><p>//todo</p>\n<h4 id=\"O-VN-算法的存在\"><a href=\"#O-VN-算法的存在\" class=\"headerlink\" title=\"O(VN)算法的存在\"></a>O(VN)算法的存在</h4><blockquote>\n<p>多重背包问题同样有O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。</p>\n</blockquote>\n<h3 id=\"混合三种背包问题\"><a href=\"#混合三种背包问题\" class=\"headerlink\" title=\"混合三种背包问题\"></a>混合三种背包问题</h3><h4 id=\"01背包与完全背包的混合\"><a href=\"#01背包与完全背包的混合\" class=\"headerlink\" title=\"01背包与完全背包的混合\"></a>01背包与完全背包的混合</h4><h5 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i=<span class=\"number\">1.</span>.N</span><br><span class=\"line\">    <span class=\"keyword\">if</span> 第i件物品属于<span class=\"number\">01</span>背包</span><br><span class=\"line\">        <span class=\"keyword\">for</span> v=V.<span class=\"number\">.0</span></span><br><span class=\"line\">            f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> 第i件物品属于完全背包</span><br><span class=\"line\">        <span class=\"keyword\">for</span> v=<span class=\"number\">0.</span>.V</span><br><span class=\"line\">            f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"再加上多重背包\"><a href=\"#再加上多重背包\" class=\"headerlink\" title=\"再加上多重背包\"></a>再加上多重背包</h4><h5 id=\"伪代码-1\"><a href=\"#伪代码-1\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i=<span class=\"number\">1.</span>.N</span><br><span class=\"line\">    <span class=\"keyword\">if</span> 第i件物品属于<span class=\"number\">01</span>背包</span><br><span class=\"line\">        ZeroOnePack(c[i],w[i])</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> 第i件物品属于完全背包</span><br><span class=\"line\">        CompletePack(c[i],w[i])</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> 第i件物品属于多重背包</span><br><span class=\"line\">        MultiplePack(c[i],w[i],n[i])</span><br></pre></td></tr></table></figure>\n<p>参考资料<br><a href=\"https://www.kancloud.cn/kancloud/pack/70129\" target=\"_blank\" rel=\"noopener\">背包问题九讲</a><br><a href=\"https://www.cnblogs.com/fengziwei/p/7750849.html\" target=\"_blank\" rel=\"noopener\">背包问题：0-1背包、完全背包和多重背包</a></p>"},{"title":"Java核心技术学习笔记","toc":true,"date":"2019-01-21T03:30:03.000Z","_content":"\n# Java 语言学习笔记\n## 名词解释\n更改器方法与访问器方法 实例域 \n方法参数(基本&引用) 静态域\n不可变类，可变类\n对象包装器\nhandler 处理器\n已检查异常，和未检查异常\n实用工具方法 \n<!-- more -->\n## 零碎知识\n1. main 函数必须是public的\n2. final 定义变量 等于 const（C/C++）\n3. static final 用于一个常量在一个类中多个方法使用.（public static final 其他类类使用）\n4. strictfp关键字\n>可移植性是Java语言的设计目标之一， 无论在哪个虚拟机上运行，同一运算应该得到同样的结果,对于浮点数的算术运算，实现这样的可移植性是相当困难。double类型使用 64 位存储一个数值，而有些处理器使用80位浮点寄存器,这些寄存器增加了中间过程的计算精度. 但是，这个结果可能与始终在64位机器上计算的结果不一样。因此， Java 虚拟机的最初规范规定所有的中间计算都必须进行截断这种行为遭到了数值计算团体的反对。 截断计算不仅可能导致溢出，而且由于截断操作需要消耗时间，所以在计算速度上实际上要比精确计算慢。 为此，Java承认了最优性能与理想结果之间存在的冲突，并给予了改进。在默认情况下，虚拟机设计者允许对中间计算结果采用扩展的精度。但是，对于使用strictfp关键字标记的方法必须使用严格的浮点计算来生成可再生的结果。\n>* 可以把 main 方法标记为 public static strictfp void main(String[] args)于是，在main方法中的所有指令都将使用严格的浮点计算。\n>* 如果将一个类标记为 strictfp, 这个类中的所有方法都要使用严格的浮点计算。实际的计算方式将取决于 Intel 处理器的行为。\n\n> 在默认情况下，中间结果允许使用扩展 的指数， 但不允许使用扩展的尾数(Intel 芯片在截断尾数时并不损失性能)。 因此，这两种 方式的区别仅仅在于采用默认的方式不会产生溢出，而采用严格的计算有可能产生溢出。\n\n5. C++ 注释: 不要在 boolean 类型与任何数值类型之间进行强制类型转换，这样可以防止发生错误。只有极少数的情况才需要将布尔类型转换为数值类型，这时可以使用条件表达式b? 1:0\n6. 不可变字符串：由于不能修改Java字符串中的字符，所以在Java文档中将String 类对象称为不可变字符串，如同数字3永远是数字3—样，字符串“ Hello”永远包含字符H、e、1、1和o的代 码单元序列，而不能修改其中的任何一个字符。\n7. char 数据类型是一 个采用 UTF-16 编码表示 Unicode 码点的代码单元。 大多数的常用 Unicode 字符使用一个代 码单元就可以表示， 而辅助字符需要一对代码单元表示。\n8. ![image.png](https://i.loli.net/2019/01/21/5c453af4afdf3.png)\n9. java的cmake？\n> javac Employee*.java\n于是， 所有与通配符匹配的源文件都将被编译成类文件。 或者键人下列命令: \njavac EmployeeTest.java\n读者可能会感到惊讶， 使用第二种方式， 并没有显式地编译 Employeejava 然而， 当 Java 编 译器发现 EmployeeTestjava 使用了Employee 类时会查找名为 Employee.class 的文件。 如果没有找 到这个文件， 就会自动地搜索 Employeejava, 然后， 对它进行编译。更重要的是: 如果 Employee.java 版本较已有的 Employee.class 文件版本新， Java 编译器就会自动地重新编译这个文件。\n10. `janes.EmployeeCJames Bond\", 250000, 1950, 1, 1) // ERROR`\n11. 所有的 Java 对象都是在堆中构造的。\n ```java\nEmployee number007(\"]anie5 Bond\", 100000, 1950, 1, 1);//此种方式是在栈中建立\n// C++, not Java\n ```\n12. 下面总结一下 Java 中方法参数的使用情况:         \n* 一个方法不能修改一个基本数据类型的参数 (即数值型或布尔型)。 \n* 一个方法可以改变一个对象参数的状态。 \n* 一个方法不能让对象参数引用一个新的对象\n13. 如果类中提供了至少一个构造器，但是没有提供无参数的构造器， 则在构造对象时如果 没有提供参数就会被视为不合法。\n14. 初始值不一定是常量值。\n ```java\n class Employee{\n    private static int nextld;\n    private int id = assignld();\n    private static int assignld{ \n    int r = nextld; nextld++;\n    return r;\n    }\n}\n```\n\n15. java内存结构\n[![](https://i.loli.net/2019/01/02/5c2b9bf995574.png)](https://i.loli.net/2019/01/02/5c2b9bf995574.png)\n\n\n\n\n16. 对象初始化块（要在实例域后定义）和静态初始化块\n```java\n    (static) class Some{\n      private int a;\n        {\n            a++;\n        }\n    }\n```\n\n17. import 语句不仅可以导入类，还增加了导人`静态方法`和`静态域`的功能。\n18. 标记为 public 的部分可以被任意的类使 用;标记为private的部分只能被定义它们的类使用。如果没有指定public或private,这个部分(类、方法或变量)可以被同一个包中的所有方法访问。\n19. 类文件存储在文件系统的子目录中。类的路径必须与包名匹配。\n20. 为了使类能够被多个程序共享， 需要做到下面几点:\n> * 把类放到一个目录中 例如 /home/user/classdir 需要注意 这个目录是包树状结构的基目录。如果希望将com.horstmann.corejava.Employee 类添加到其中， 这个 Employee.class 类文件就必须位于子目录 /home/user/classdir/com/horstmann/corejava中。\n> * 将 JAR 文件放在一个目录中， 例如:/home/user/archives。\n> * 设置类路径(classpath)。类路径是所有包含类文件的路径的集合。\n* 在 UNIX 环境中， 类路径中的不同项目之间采用冒号 (一) 分隔:\n /home/user/classdir:.: /home/user/archives/archive .jar\n* 在 Windows 环境中， 则以分号(;)分隔:\nc:\\classdir;.;c:\\archives\\ archive.jar\n\n21. 假定虚拟机要搜寻com.horstmann.corejava.Employee 类文件。它首先要查看存储在jre/lib和jre/lib/ext目录下的归档文件中所存放的系统类文件。显然,在那里找不到相应的类文件,然后再查看类路径。然后查找以下文件:\n* /home/user/classdir/com/horstmann/corejava/Employee.class\n*  ./com/horstmann/corejava/Employee.class \n*  com/horstmann/corejava/Employee.class inside /home/user/archives/archive.jar\n\n编译器定位文件要比虚拟机复杂得多。如果引用了一个类，而没有指出这个类所在的包，那么编译器将首先查找包含这个类的包，并询查所有的 import 指令，确定其中是否包含了被引用的类。 例如， 假定源文件包含指令:\n`import java.util.*;`\n`import com.horstmann.corejava.*;`\n并且源代码引用了 Employee 类。 编译器将试图查找 java.lang.Employee ( 因为 java.lang 包被 默认导入 )、 java.util.Employee、 com.horstmann.corejava.Employee 和当前包中的 Employee。\n22. 为什么优先使用不可变类：更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改。其结果是不可预料的。如果类是不可变的，就可以安全地在多个线程间共享其对象。\n23. 关键字this有两个用途：一是引用隐式参数，二是调用该类其他的构造器，同样，super关键字也有两个用途:一是调用超类的方法， 二是调用超类的构造器。\n24.   JAVA多态的问题\n![image.png](https://i.loli.net/2019/01/21/5c453b3d75180.png)\n25. 方法的名字和参数列表称为方法的签名\n26. 下面归纳一下Java 用于控制可见性的4个访问修饰符\n\n* 仅对本类可见————private。\n* 对所有类可见————public。\n* 对本包和所有子类可见————protected\n* 对本包可见————默认（很遗憾)，不需要修饰符.\n\n27. 为了防备name或hireDay可能为null的情况，需要使用Objects.equals 方法。\n28. 关于equals方法\n> 1. （默认方法）Object的equals方法检测两个类是否具有相同的引用。(但我们的需求经常是连个类的状态（域）相等即为相等，但这也不绝对，所以对于一个对象怎样算相等应当具体问题具体分析)\n> 2. 两给类的状态相等即为相等这一情况又一般分为两种情况：\n> * 例如AbstractSet.equals中的equals被定义为final（实际并不是，但后续覆盖的话基本思想不变只是使算法更高效），这是由于TreeSet和HashSet的实例也应当可以相等，只要他们包含的元素一样。一般来讲（上面特例），此时对于该类的所有子类都不允许重载。(对所有的AbstractSet子类都有同样的“语义”)\n> * 严格控制只有实例的class相同才可能相等。\n> 3. 下面给出编写一个完美的equals 方法的建议：\n1 ) 显式参数命名为otherObject, 稍后需要将它转换成另一个叫做other 的变量。\n2 ) 检测this与otherObject 是否引用同一个对象：\n`if (this = otherObject) return true;`\n3 ) 检测otherObject 是否为null .\n`if (otherObject = null ) return false;`\n4 ) 比较this 与otherObject 是否属于同一个类。如果equals 的语义在每个子类中有所改变，就使用getClass 检测：\n`if (getClass() != otherObject.getCIass()) return false;`\n如果所有的子类都拥有统一的语义，就使用instanceof 检测：\n`if (!(otherObject instanceof ClassName)) return false;`\n5 ) 将otherObject 转换为相应的类类型变量：\n`ClassName other = (ClassName) otherObject`\n6 ) 现在开始对所有需要比较的域进行比较了。使用== 比较基本类型域，使用equals比\n较对象域。如果所有的域都匹配，就返回true; 否则返回false。\n`return fieldl == other.field&& Objects.equa1s(fie1d2,`\n`other.field2)`\n**如果在子类中重新定义equals**,就要在其中包含调用super.equals(other)  \n\n29. 对于数组类型的域，可以使用静态的Arrays.equals方法检测相应的数组元素是否相等。\n\n30.hashcodeAPI\n`int type.hashcode(type instance);`\n`Objects.hash(name, salary, hireDay) ;`\n`static int java.util.Arrays.hashCode(type[] a)`\n31.Equals 与hashCode 的定义必须一致：如果x.equals(y) 返回true, 那么x.hashCode()就必须与y.hashCode()具有相同的值。例如，如果用定义的Employee.equals比较雇员的ID，那么hashCode 方法就需要散列ID，而不是雇员的姓名或存储地址。\n32. 这就是Java 中不尽如人意的参数化类型的限制所带来的结果。鉴于兼容性的考虑，编译器在对类型转换进行检査之后， 如果没有发现违反规则的现象，就将所有的类型化数组列表转换成原始ArrayList对象。在程序运行时， 所有的数组列表都是一样的，即没有虚拟机中的类型参数。因此，类型转换（ArrayList ) 和( ArrayList<Employee> ) 将执行相同的运行时检查。\n33. 下面这个调用\n`list.add(3);`\n将自动地变换成\n`list.add(Integer.value0f(3)) ;`\n这种变换被称为**自动装箱（autoboxing)**。\nint n = list.get(i);\n翻译成\nint n = list.get(i).intValue();\n这种变换被称为**自动拆箱（autoboxing)**.\n在算术表达式中也能够自动地装箱和拆箱：\n`Integer n = 3;`\n`n++;`\n自动拆装箱是编译器操作而不是虚拟机操作，编译器在编译时添加适当方法\n34. 注意区分不可变对象和可变对象。\n35. 可以将已经存在且**最后一个**参数是数组的方法重新定义为可变参数的方法，而不会破坏任何已经存在的代码,Object… 参数类型与Object[] 完全一样, 当然基本类型也是可以，如下面的例子。\n```java\npublic static double max(double... values)\n{\n    double largest = Double.NECATIVEJNFINITY;\n    for (double v : values) if (v > largest) largest = v;\n    return largest;\n}\n```\n36. 枚举：`public enuni Size { SMALL, MEDIUM, LARGE, EXTRAJARGE };`\n实际上，这个声明定义的类型是一个类， 它刚好有4 个实例， 在此尽量不要构造新对象。\n因此， 在比较两个枚举类型的值时， 永远不需要调用equals, 而直接使用“ = =” 就\n可以了。\n37. 枚举的复杂用法：\n```java\npublic enum Size\n{\n    SMALL(\"S\"), MEDIUM(\"M\") , LARGE(\"L\") , EXTRA_LARGE(\"XL\");//只有四个对象\n    private String abbreviation;\n    private Size(String abbreviation) { this,abbreviation = abbreviation; }\n    public String getAbbreviation() { return abbreviation; }\n}\n```\n\n`Size s = Enum.valueOf(Size.class, \"SMALL\");`\n`Size[] Size.values()`\n38. 反射\n> `Class cl = Cl ass.forName(className) ;`\n鉴于历史原getName 方法在应用于数组类型的时候会返回一个很奇怪的名字：\n• Double[] class.getName() 返回“ [Ljava.lang.Double; ’’\n• int[].class.getName()返回“ [I ” ，\n虚拟机为每个类型管理一个Class对象。因此， 可以利用=运算符实现两个类对象比较的操作\n> Class 类的getDeclareFields、getDeclareMethods和getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器， 其中包括私有和受保护成员，但不包括超类的成员。\n\n\n39. Java 数组会记住每个元素的类型， 即创建数组时new 表达式中使用的元素类型。将一个Employee[ ]临时地转换成Object[ ] 数组， 然后再把它转换回来是可以的，但一从开始就是Objectt ] 的数组却永远不能转换成Employe [] 数组。\n下面是java.util.Arrays.copyof的实现。\n```java\npublic static Object badCopyOf(Object[] a, int newLength) // not useful\n{\n    ObjectD newArray = new Object[newlength]:\n    System.arraycopy(a, 0, newArray, 0, Math.min(a.length, newLength)) ;\n    //注意这个方法\n    return newArray;\n}\npublic static Object goodCopyOf(Object a, int newLength)\n{\n    Class cl = a.getClass()；\n    if (！cl.isArray()) return null ;\n    Class componentType = cl.getComponentType()；//注意\n    int length = Array.getLength(a);\n    Object newArray = Array.newlnstance(componentType, newLength) ://注意 java.lang.Array\n    System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength)) ;\n    return newArray;\n}\n```\n40. 调用任意方法\n`Object invoke(Object obj, Object... args)` 如果是静态方法obj填null\n41. 虽然在接口中不能包含实例域或**静态方法(java8之前)**，但却可以包含常量.\n42. 目前为止， 通常的做法都是将静态方法放在伴随类中。在标准库中， 你会看到成对出现\n的接口和实用工具类， 如Collection/Collections 或Path/Paths。面来看Paths 类， 其中只包含两个工厂方法。可以由一个字符串序列构造一个文件或目录的路径， 如Paths.get(\"jdk1.8.0\", \"jre\", \"bin\")。在Java SE 8中， 可以为Path 接口增加以下方法：\n```java\npublic interface Path{\n    public static Path get(String first, String... more) {\n    return Fi1eSystems.getDefault().getPath(first, more);\n    }\n}\n```\n这样一来， Paths 类就不再是必要的了。\n43. default关键字：用于接口中方法的声明，意为接口中的实现为默认实现，如果实现接口的类不覆盖则使用这个实现。\n44. 默认方法的一个重要用法是“接口演化” （interface evolution)。\n45. 我们只讨论了两个接口的命名冲突。现在来考虑另一种情况，一个类扩展了一个超类，同时实现了一个接口，并从超类和接口继承了相同的方法。例如，假设Person 是一个类，Student 定义为：class Student extends Person implements Named { . . . }在这种情况下， 只会考虑超类方法， 接口的所有默认方法都会被忽略。在我们的例子中， Student从Person继承了getName方法，Named接口是否为getName提供了默认实现并不会带来什么区别。这正是“ 类优先” 规则。\n46. 尽管LengthComparator对象没有状态，不过还是需要建立这个对象的一个实例。我们需要这个实例来调用compare方法，它不是一个静态方法。\n47. 通常子对象都是可变的，必须重新定义clone方法来建立一个深拷贝，同时克隆所有子对象。在这个例子中，hireDay域是一个Date,这是可变的，所以它也需要克隆。（出于这个原因，这个例子使用Date类型的域而不是LocalDate来展示克隆过程。如果hireDay是不可变的LocalDate类的一个实例，就无需我们做任何处理了。）\n![image.png](https://i.loli.net/2019/01/21/5c453bea3e69d.png)\n48. Cloneable 接口是Java提供的一组标记接口(tagging interface) 之一\n标记接口不包含任何方法；它唯一的作用就是允许在类型查询中使用instanceof。即使clone的默认（浅拷贝）实现能够满足要求（实例域全部是不可变时），还是需要实现Cloneable接口，将clone重新定义为public， 再调用super.clone()。\n49. 如果在一个对象上调用clone,但这个对象的类并没有实现Cloneable接口，Object 类的clone方法就会拋出一个CloneNotSupportedException当然，Employee和Date类实现了Cloneable 接口，所以不会抛出这个异常。不过，编译器并不了解这一点，因此，我们声明了这个异常。\n50. 所有数组类型都有一个public的clone 方法，而不是protected,可以用这个方法\n建立一个新数组，包含原数组所有元素的副本。\n51. 对于只有一个抽象方法的接口， 需要这种接口的对象时，就可以提供一个lambda 表达式。这种接口称为函数式接口（ functional interface )。\n52. 甚至不能把lambda表达式赋给类型为Object的变量，Object不是一个函数式接口。\n53. \n```java\njava.util.function 包中有一个尤其有用的接口Predicate:\npublic interface Predicate<T>\n{\n    boolean test(T t);\n    // Additional default and static methods\n}\nArrayList 类有一个removelf 方法， 它的参数就是一个Predicate。这个接口专门用来传递\nlambda 表达式。例如，下面的语句将从一个数组列表删除所有null值：\nlist.removelf(e -> e == null);\n```\n54. 方法引用：一种lambda表达式简化方式，根据lamdba表达式所在的函数式接口的位置，确定\n>从这些例子可以看出， 要用::操作符分隔方法名与对象或类名。主要有3 种情况：\n* object::instanceMethod\n* Class::staticMethod\n* Class::instanceMethod\n在前2 种情况中， 方法引用等价于提供方法参数的lambda 表达式。前面已经提到，\nSystem.out::println 等价于x -> System.out.println(x)。 类似地，Math::pow 等价于（x，y) ->Math.pow(x, y)。\n对于第3 种情况， 第1个参数会成为方法的目标。例如，String::compareToIgnoreCase 等同于(x, y) -> x.compareToIgnoreCase(y);\n55. lambda 表达式中捕获的变量必须实际上是**最终变量( effectivelyfinal)**。实际上的最终变量是指， 这个变量初始化之后就不会再为它赋新值。在这里，text 总是指示同一个 String对象，所以捕获这个变量是合法的。不过，i的值会改变，因此不能捕获i。\n56. 内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域.为了能够运行这个程序，内部类的对象总有一个隐式引用，它指向了创建它的外部类对象。\n57. TimePrinter 类声明为私有的。这样一来，只有TalkingClock的方法才能够构造TimePrinter 对象。只有内部类可以是私有类，而常规类只可以具有包可见性，或公有可见性。\n58. 外围类，内部类。\n59. 使用静态内部类的原因，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。为此，可以将内部类声明为static,以便取消产生的引用。\n60. 这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用，对于用程序设计人员来说，遇到这种情况的机会很少。\n61. “ 如果出现RuntimeException 异常， 那么就一定是你的问题” 是一条相当有道理的规则。\n应该通过检测数组下标是否越界来避免ArraylndexOutOfBoundsException 异常；应该通过在使用变量之前检测是否为null来杜绝NullPointerException异常的发生：\n62. 前面曾经提到过：如果编写一个覆盖超类的方法，而这个方法又没有抛出异常（如JComponent中的paintComponent),那么这个方法就必须捕获方法代码中出现的每一个受查异常。不许在子类的throws 说明符中出现超过超类方法所列出的异常类范围。\n63. catch (FileNotFoundException | UnknownHostException e) { . . . }\n64. 同样，也不应该声明从RuntimeException 继承的那些非受查异常.\n```java \nclass MyAnimation\n{\n    void drawlmage(int i) throws ArraylndexOutOfBoundsException // bad style\n    {\n    }\n}\n```\n65. 未被任何变量引用的日志记录器可能会被垃圾回收。为了防止这种情况发生，要像上面的例子中一样，用一个静态变量存储日志记录器的一个引用。\n\n## JAVA和C++的区别\n\n| 什么方面 | JAVA | C++ | 备注 |\n| --- | --- | --- | --- |\n| 类中函数 | 方法 | 成员函数 | |\n| 字面数值表示 | 可以加下划线 | 不可以 | |\n| 进制表示 | 可表示二进制（0b或0B） | 不可以 | |\n| 无符号数 | 没有 | 有 | |\n| 逗号运算符 | 没有 | 有 | |\n| 更改器方法与访问器方法 | 无明显区别 | const关键字 | |\n| 方法参数 | 按值（引用也是按值） | 真引用（换个名字） | |\n  [2]: https://www.nobler.xyz/wp-content/uploads/2019/01/WX20190106-145446.png","source":"_posts/Java核心技术学习笔记.md","raw":"---\ntitle: Java核心技术学习笔记\ntags:\n  - 语言\n  - 基础\n  - Java\n  - 笔记\ncategories:\n  - Java\ntoc: true\ndate: 2019-01-21 11:30:03\n---\n\n# Java 语言学习笔记\n## 名词解释\n更改器方法与访问器方法 实例域 \n方法参数(基本&引用) 静态域\n不可变类，可变类\n对象包装器\nhandler 处理器\n已检查异常，和未检查异常\n实用工具方法 \n<!-- more -->\n## 零碎知识\n1. main 函数必须是public的\n2. final 定义变量 等于 const（C/C++）\n3. static final 用于一个常量在一个类中多个方法使用.（public static final 其他类类使用）\n4. strictfp关键字\n>可移植性是Java语言的设计目标之一， 无论在哪个虚拟机上运行，同一运算应该得到同样的结果,对于浮点数的算术运算，实现这样的可移植性是相当困难。double类型使用 64 位存储一个数值，而有些处理器使用80位浮点寄存器,这些寄存器增加了中间过程的计算精度. 但是，这个结果可能与始终在64位机器上计算的结果不一样。因此， Java 虚拟机的最初规范规定所有的中间计算都必须进行截断这种行为遭到了数值计算团体的反对。 截断计算不仅可能导致溢出，而且由于截断操作需要消耗时间，所以在计算速度上实际上要比精确计算慢。 为此，Java承认了最优性能与理想结果之间存在的冲突，并给予了改进。在默认情况下，虚拟机设计者允许对中间计算结果采用扩展的精度。但是，对于使用strictfp关键字标记的方法必须使用严格的浮点计算来生成可再生的结果。\n>* 可以把 main 方法标记为 public static strictfp void main(String[] args)于是，在main方法中的所有指令都将使用严格的浮点计算。\n>* 如果将一个类标记为 strictfp, 这个类中的所有方法都要使用严格的浮点计算。实际的计算方式将取决于 Intel 处理器的行为。\n\n> 在默认情况下，中间结果允许使用扩展 的指数， 但不允许使用扩展的尾数(Intel 芯片在截断尾数时并不损失性能)。 因此，这两种 方式的区别仅仅在于采用默认的方式不会产生溢出，而采用严格的计算有可能产生溢出。\n\n5. C++ 注释: 不要在 boolean 类型与任何数值类型之间进行强制类型转换，这样可以防止发生错误。只有极少数的情况才需要将布尔类型转换为数值类型，这时可以使用条件表达式b? 1:0\n6. 不可变字符串：由于不能修改Java字符串中的字符，所以在Java文档中将String 类对象称为不可变字符串，如同数字3永远是数字3—样，字符串“ Hello”永远包含字符H、e、1、1和o的代 码单元序列，而不能修改其中的任何一个字符。\n7. char 数据类型是一 个采用 UTF-16 编码表示 Unicode 码点的代码单元。 大多数的常用 Unicode 字符使用一个代 码单元就可以表示， 而辅助字符需要一对代码单元表示。\n8. ![image.png](https://i.loli.net/2019/01/21/5c453af4afdf3.png)\n9. java的cmake？\n> javac Employee*.java\n于是， 所有与通配符匹配的源文件都将被编译成类文件。 或者键人下列命令: \njavac EmployeeTest.java\n读者可能会感到惊讶， 使用第二种方式， 并没有显式地编译 Employeejava 然而， 当 Java 编 译器发现 EmployeeTestjava 使用了Employee 类时会查找名为 Employee.class 的文件。 如果没有找 到这个文件， 就会自动地搜索 Employeejava, 然后， 对它进行编译。更重要的是: 如果 Employee.java 版本较已有的 Employee.class 文件版本新， Java 编译器就会自动地重新编译这个文件。\n10. `janes.EmployeeCJames Bond\", 250000, 1950, 1, 1) // ERROR`\n11. 所有的 Java 对象都是在堆中构造的。\n ```java\nEmployee number007(\"]anie5 Bond\", 100000, 1950, 1, 1);//此种方式是在栈中建立\n// C++, not Java\n ```\n12. 下面总结一下 Java 中方法参数的使用情况:         \n* 一个方法不能修改一个基本数据类型的参数 (即数值型或布尔型)。 \n* 一个方法可以改变一个对象参数的状态。 \n* 一个方法不能让对象参数引用一个新的对象\n13. 如果类中提供了至少一个构造器，但是没有提供无参数的构造器， 则在构造对象时如果 没有提供参数就会被视为不合法。\n14. 初始值不一定是常量值。\n ```java\n class Employee{\n    private static int nextld;\n    private int id = assignld();\n    private static int assignld{ \n    int r = nextld; nextld++;\n    return r;\n    }\n}\n```\n\n15. java内存结构\n[![](https://i.loli.net/2019/01/02/5c2b9bf995574.png)](https://i.loli.net/2019/01/02/5c2b9bf995574.png)\n\n\n\n\n16. 对象初始化块（要在实例域后定义）和静态初始化块\n```java\n    (static) class Some{\n      private int a;\n        {\n            a++;\n        }\n    }\n```\n\n17. import 语句不仅可以导入类，还增加了导人`静态方法`和`静态域`的功能。\n18. 标记为 public 的部分可以被任意的类使 用;标记为private的部分只能被定义它们的类使用。如果没有指定public或private,这个部分(类、方法或变量)可以被同一个包中的所有方法访问。\n19. 类文件存储在文件系统的子目录中。类的路径必须与包名匹配。\n20. 为了使类能够被多个程序共享， 需要做到下面几点:\n> * 把类放到一个目录中 例如 /home/user/classdir 需要注意 这个目录是包树状结构的基目录。如果希望将com.horstmann.corejava.Employee 类添加到其中， 这个 Employee.class 类文件就必须位于子目录 /home/user/classdir/com/horstmann/corejava中。\n> * 将 JAR 文件放在一个目录中， 例如:/home/user/archives。\n> * 设置类路径(classpath)。类路径是所有包含类文件的路径的集合。\n* 在 UNIX 环境中， 类路径中的不同项目之间采用冒号 (一) 分隔:\n /home/user/classdir:.: /home/user/archives/archive .jar\n* 在 Windows 环境中， 则以分号(;)分隔:\nc:\\classdir;.;c:\\archives\\ archive.jar\n\n21. 假定虚拟机要搜寻com.horstmann.corejava.Employee 类文件。它首先要查看存储在jre/lib和jre/lib/ext目录下的归档文件中所存放的系统类文件。显然,在那里找不到相应的类文件,然后再查看类路径。然后查找以下文件:\n* /home/user/classdir/com/horstmann/corejava/Employee.class\n*  ./com/horstmann/corejava/Employee.class \n*  com/horstmann/corejava/Employee.class inside /home/user/archives/archive.jar\n\n编译器定位文件要比虚拟机复杂得多。如果引用了一个类，而没有指出这个类所在的包，那么编译器将首先查找包含这个类的包，并询查所有的 import 指令，确定其中是否包含了被引用的类。 例如， 假定源文件包含指令:\n`import java.util.*;`\n`import com.horstmann.corejava.*;`\n并且源代码引用了 Employee 类。 编译器将试图查找 java.lang.Employee ( 因为 java.lang 包被 默认导入 )、 java.util.Employee、 com.horstmann.corejava.Employee 和当前包中的 Employee。\n22. 为什么优先使用不可变类：更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改。其结果是不可预料的。如果类是不可变的，就可以安全地在多个线程间共享其对象。\n23. 关键字this有两个用途：一是引用隐式参数，二是调用该类其他的构造器，同样，super关键字也有两个用途:一是调用超类的方法， 二是调用超类的构造器。\n24.   JAVA多态的问题\n![image.png](https://i.loli.net/2019/01/21/5c453b3d75180.png)\n25. 方法的名字和参数列表称为方法的签名\n26. 下面归纳一下Java 用于控制可见性的4个访问修饰符\n\n* 仅对本类可见————private。\n* 对所有类可见————public。\n* 对本包和所有子类可见————protected\n* 对本包可见————默认（很遗憾)，不需要修饰符.\n\n27. 为了防备name或hireDay可能为null的情况，需要使用Objects.equals 方法。\n28. 关于equals方法\n> 1. （默认方法）Object的equals方法检测两个类是否具有相同的引用。(但我们的需求经常是连个类的状态（域）相等即为相等，但这也不绝对，所以对于一个对象怎样算相等应当具体问题具体分析)\n> 2. 两给类的状态相等即为相等这一情况又一般分为两种情况：\n> * 例如AbstractSet.equals中的equals被定义为final（实际并不是，但后续覆盖的话基本思想不变只是使算法更高效），这是由于TreeSet和HashSet的实例也应当可以相等，只要他们包含的元素一样。一般来讲（上面特例），此时对于该类的所有子类都不允许重载。(对所有的AbstractSet子类都有同样的“语义”)\n> * 严格控制只有实例的class相同才可能相等。\n> 3. 下面给出编写一个完美的equals 方法的建议：\n1 ) 显式参数命名为otherObject, 稍后需要将它转换成另一个叫做other 的变量。\n2 ) 检测this与otherObject 是否引用同一个对象：\n`if (this = otherObject) return true;`\n3 ) 检测otherObject 是否为null .\n`if (otherObject = null ) return false;`\n4 ) 比较this 与otherObject 是否属于同一个类。如果equals 的语义在每个子类中有所改变，就使用getClass 检测：\n`if (getClass() != otherObject.getCIass()) return false;`\n如果所有的子类都拥有统一的语义，就使用instanceof 检测：\n`if (!(otherObject instanceof ClassName)) return false;`\n5 ) 将otherObject 转换为相应的类类型变量：\n`ClassName other = (ClassName) otherObject`\n6 ) 现在开始对所有需要比较的域进行比较了。使用== 比较基本类型域，使用equals比\n较对象域。如果所有的域都匹配，就返回true; 否则返回false。\n`return fieldl == other.field&& Objects.equa1s(fie1d2,`\n`other.field2)`\n**如果在子类中重新定义equals**,就要在其中包含调用super.equals(other)  \n\n29. 对于数组类型的域，可以使用静态的Arrays.equals方法检测相应的数组元素是否相等。\n\n30.hashcodeAPI\n`int type.hashcode(type instance);`\n`Objects.hash(name, salary, hireDay) ;`\n`static int java.util.Arrays.hashCode(type[] a)`\n31.Equals 与hashCode 的定义必须一致：如果x.equals(y) 返回true, 那么x.hashCode()就必须与y.hashCode()具有相同的值。例如，如果用定义的Employee.equals比较雇员的ID，那么hashCode 方法就需要散列ID，而不是雇员的姓名或存储地址。\n32. 这就是Java 中不尽如人意的参数化类型的限制所带来的结果。鉴于兼容性的考虑，编译器在对类型转换进行检査之后， 如果没有发现违反规则的现象，就将所有的类型化数组列表转换成原始ArrayList对象。在程序运行时， 所有的数组列表都是一样的，即没有虚拟机中的类型参数。因此，类型转换（ArrayList ) 和( ArrayList<Employee> ) 将执行相同的运行时检查。\n33. 下面这个调用\n`list.add(3);`\n将自动地变换成\n`list.add(Integer.value0f(3)) ;`\n这种变换被称为**自动装箱（autoboxing)**。\nint n = list.get(i);\n翻译成\nint n = list.get(i).intValue();\n这种变换被称为**自动拆箱（autoboxing)**.\n在算术表达式中也能够自动地装箱和拆箱：\n`Integer n = 3;`\n`n++;`\n自动拆装箱是编译器操作而不是虚拟机操作，编译器在编译时添加适当方法\n34. 注意区分不可变对象和可变对象。\n35. 可以将已经存在且**最后一个**参数是数组的方法重新定义为可变参数的方法，而不会破坏任何已经存在的代码,Object… 参数类型与Object[] 完全一样, 当然基本类型也是可以，如下面的例子。\n```java\npublic static double max(double... values)\n{\n    double largest = Double.NECATIVEJNFINITY;\n    for (double v : values) if (v > largest) largest = v;\n    return largest;\n}\n```\n36. 枚举：`public enuni Size { SMALL, MEDIUM, LARGE, EXTRAJARGE };`\n实际上，这个声明定义的类型是一个类， 它刚好有4 个实例， 在此尽量不要构造新对象。\n因此， 在比较两个枚举类型的值时， 永远不需要调用equals, 而直接使用“ = =” 就\n可以了。\n37. 枚举的复杂用法：\n```java\npublic enum Size\n{\n    SMALL(\"S\"), MEDIUM(\"M\") , LARGE(\"L\") , EXTRA_LARGE(\"XL\");//只有四个对象\n    private String abbreviation;\n    private Size(String abbreviation) { this,abbreviation = abbreviation; }\n    public String getAbbreviation() { return abbreviation; }\n}\n```\n\n`Size s = Enum.valueOf(Size.class, \"SMALL\");`\n`Size[] Size.values()`\n38. 反射\n> `Class cl = Cl ass.forName(className) ;`\n鉴于历史原getName 方法在应用于数组类型的时候会返回一个很奇怪的名字：\n• Double[] class.getName() 返回“ [Ljava.lang.Double; ’’\n• int[].class.getName()返回“ [I ” ，\n虚拟机为每个类型管理一个Class对象。因此， 可以利用=运算符实现两个类对象比较的操作\n> Class 类的getDeclareFields、getDeclareMethods和getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器， 其中包括私有和受保护成员，但不包括超类的成员。\n\n\n39. Java 数组会记住每个元素的类型， 即创建数组时new 表达式中使用的元素类型。将一个Employee[ ]临时地转换成Object[ ] 数组， 然后再把它转换回来是可以的，但一从开始就是Objectt ] 的数组却永远不能转换成Employe [] 数组。\n下面是java.util.Arrays.copyof的实现。\n```java\npublic static Object badCopyOf(Object[] a, int newLength) // not useful\n{\n    ObjectD newArray = new Object[newlength]:\n    System.arraycopy(a, 0, newArray, 0, Math.min(a.length, newLength)) ;\n    //注意这个方法\n    return newArray;\n}\npublic static Object goodCopyOf(Object a, int newLength)\n{\n    Class cl = a.getClass()；\n    if (！cl.isArray()) return null ;\n    Class componentType = cl.getComponentType()；//注意\n    int length = Array.getLength(a);\n    Object newArray = Array.newlnstance(componentType, newLength) ://注意 java.lang.Array\n    System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength)) ;\n    return newArray;\n}\n```\n40. 调用任意方法\n`Object invoke(Object obj, Object... args)` 如果是静态方法obj填null\n41. 虽然在接口中不能包含实例域或**静态方法(java8之前)**，但却可以包含常量.\n42. 目前为止， 通常的做法都是将静态方法放在伴随类中。在标准库中， 你会看到成对出现\n的接口和实用工具类， 如Collection/Collections 或Path/Paths。面来看Paths 类， 其中只包含两个工厂方法。可以由一个字符串序列构造一个文件或目录的路径， 如Paths.get(\"jdk1.8.0\", \"jre\", \"bin\")。在Java SE 8中， 可以为Path 接口增加以下方法：\n```java\npublic interface Path{\n    public static Path get(String first, String... more) {\n    return Fi1eSystems.getDefault().getPath(first, more);\n    }\n}\n```\n这样一来， Paths 类就不再是必要的了。\n43. default关键字：用于接口中方法的声明，意为接口中的实现为默认实现，如果实现接口的类不覆盖则使用这个实现。\n44. 默认方法的一个重要用法是“接口演化” （interface evolution)。\n45. 我们只讨论了两个接口的命名冲突。现在来考虑另一种情况，一个类扩展了一个超类，同时实现了一个接口，并从超类和接口继承了相同的方法。例如，假设Person 是一个类，Student 定义为：class Student extends Person implements Named { . . . }在这种情况下， 只会考虑超类方法， 接口的所有默认方法都会被忽略。在我们的例子中， Student从Person继承了getName方法，Named接口是否为getName提供了默认实现并不会带来什么区别。这正是“ 类优先” 规则。\n46. 尽管LengthComparator对象没有状态，不过还是需要建立这个对象的一个实例。我们需要这个实例来调用compare方法，它不是一个静态方法。\n47. 通常子对象都是可变的，必须重新定义clone方法来建立一个深拷贝，同时克隆所有子对象。在这个例子中，hireDay域是一个Date,这是可变的，所以它也需要克隆。（出于这个原因，这个例子使用Date类型的域而不是LocalDate来展示克隆过程。如果hireDay是不可变的LocalDate类的一个实例，就无需我们做任何处理了。）\n![image.png](https://i.loli.net/2019/01/21/5c453bea3e69d.png)\n48. Cloneable 接口是Java提供的一组标记接口(tagging interface) 之一\n标记接口不包含任何方法；它唯一的作用就是允许在类型查询中使用instanceof。即使clone的默认（浅拷贝）实现能够满足要求（实例域全部是不可变时），还是需要实现Cloneable接口，将clone重新定义为public， 再调用super.clone()。\n49. 如果在一个对象上调用clone,但这个对象的类并没有实现Cloneable接口，Object 类的clone方法就会拋出一个CloneNotSupportedException当然，Employee和Date类实现了Cloneable 接口，所以不会抛出这个异常。不过，编译器并不了解这一点，因此，我们声明了这个异常。\n50. 所有数组类型都有一个public的clone 方法，而不是protected,可以用这个方法\n建立一个新数组，包含原数组所有元素的副本。\n51. 对于只有一个抽象方法的接口， 需要这种接口的对象时，就可以提供一个lambda 表达式。这种接口称为函数式接口（ functional interface )。\n52. 甚至不能把lambda表达式赋给类型为Object的变量，Object不是一个函数式接口。\n53. \n```java\njava.util.function 包中有一个尤其有用的接口Predicate:\npublic interface Predicate<T>\n{\n    boolean test(T t);\n    // Additional default and static methods\n}\nArrayList 类有一个removelf 方法， 它的参数就是一个Predicate。这个接口专门用来传递\nlambda 表达式。例如，下面的语句将从一个数组列表删除所有null值：\nlist.removelf(e -> e == null);\n```\n54. 方法引用：一种lambda表达式简化方式，根据lamdba表达式所在的函数式接口的位置，确定\n>从这些例子可以看出， 要用::操作符分隔方法名与对象或类名。主要有3 种情况：\n* object::instanceMethod\n* Class::staticMethod\n* Class::instanceMethod\n在前2 种情况中， 方法引用等价于提供方法参数的lambda 表达式。前面已经提到，\nSystem.out::println 等价于x -> System.out.println(x)。 类似地，Math::pow 等价于（x，y) ->Math.pow(x, y)。\n对于第3 种情况， 第1个参数会成为方法的目标。例如，String::compareToIgnoreCase 等同于(x, y) -> x.compareToIgnoreCase(y);\n55. lambda 表达式中捕获的变量必须实际上是**最终变量( effectivelyfinal)**。实际上的最终变量是指， 这个变量初始化之后就不会再为它赋新值。在这里，text 总是指示同一个 String对象，所以捕获这个变量是合法的。不过，i的值会改变，因此不能捕获i。\n56. 内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域.为了能够运行这个程序，内部类的对象总有一个隐式引用，它指向了创建它的外部类对象。\n57. TimePrinter 类声明为私有的。这样一来，只有TalkingClock的方法才能够构造TimePrinter 对象。只有内部类可以是私有类，而常规类只可以具有包可见性，或公有可见性。\n58. 外围类，内部类。\n59. 使用静态内部类的原因，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。为此，可以将内部类声明为static,以便取消产生的引用。\n60. 这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用，对于用程序设计人员来说，遇到这种情况的机会很少。\n61. “ 如果出现RuntimeException 异常， 那么就一定是你的问题” 是一条相当有道理的规则。\n应该通过检测数组下标是否越界来避免ArraylndexOutOfBoundsException 异常；应该通过在使用变量之前检测是否为null来杜绝NullPointerException异常的发生：\n62. 前面曾经提到过：如果编写一个覆盖超类的方法，而这个方法又没有抛出异常（如JComponent中的paintComponent),那么这个方法就必须捕获方法代码中出现的每一个受查异常。不许在子类的throws 说明符中出现超过超类方法所列出的异常类范围。\n63. catch (FileNotFoundException | UnknownHostException e) { . . . }\n64. 同样，也不应该声明从RuntimeException 继承的那些非受查异常.\n```java \nclass MyAnimation\n{\n    void drawlmage(int i) throws ArraylndexOutOfBoundsException // bad style\n    {\n    }\n}\n```\n65. 未被任何变量引用的日志记录器可能会被垃圾回收。为了防止这种情况发生，要像上面的例子中一样，用一个静态变量存储日志记录器的一个引用。\n\n## JAVA和C++的区别\n\n| 什么方面 | JAVA | C++ | 备注 |\n| --- | --- | --- | --- |\n| 类中函数 | 方法 | 成员函数 | |\n| 字面数值表示 | 可以加下划线 | 不可以 | |\n| 进制表示 | 可表示二进制（0b或0B） | 不可以 | |\n| 无符号数 | 没有 | 有 | |\n| 逗号运算符 | 没有 | 有 | |\n| 更改器方法与访问器方法 | 无明显区别 | const关键字 | |\n| 方法参数 | 按值（引用也是按值） | 真引用（换个名字） | |\n  [2]: https://www.nobler.xyz/wp-content/uploads/2019/01/WX20190106-145446.png","slug":"Java核心技术学习笔记","published":1,"updated":"2019-09-19T12:00:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22tga3t0001wurerdso400b","content":"<h1 id=\"Java-语言学习笔记\"><a href=\"#Java-语言学习笔记\" class=\"headerlink\" title=\"Java 语言学习笔记\"></a>Java 语言学习笔记</h1><h2 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h2><p>更改器方法与访问器方法 实例域<br>方法参数(基本&amp;引用) 静态域<br>不可变类，可变类<br>对象包装器<br>handler 处理器<br>已检查异常，和未检查异常<br>实用工具方法<br><a id=\"more\"></a></p>\n<h2 id=\"零碎知识\"><a href=\"#零碎知识\" class=\"headerlink\" title=\"零碎知识\"></a>零碎知识</h2><ol>\n<li>main 函数必须是public的</li>\n<li>final 定义变量 等于 const（C/C++）</li>\n<li>static final 用于一个常量在一个类中多个方法使用.（public static final 其他类类使用）</li>\n<li>strictfp关键字<blockquote>\n<p>可移植性是Java语言的设计目标之一， 无论在哪个虚拟机上运行，同一运算应该得到同样的结果,对于浮点数的算术运算，实现这样的可移植性是相当困难。double类型使用 64 位存储一个数值，而有些处理器使用80位浮点寄存器,这些寄存器增加了中间过程的计算精度. 但是，这个结果可能与始终在64位机器上计算的结果不一样。因此， Java 虚拟机的最初规范规定所有的中间计算都必须进行截断这种行为遭到了数值计算团体的反对。 截断计算不仅可能导致溢出，而且由于截断操作需要消耗时间，所以在计算速度上实际上要比精确计算慢。 为此，Java承认了最优性能与理想结果之间存在的冲突，并给予了改进。在默认情况下，虚拟机设计者允许对中间计算结果采用扩展的精度。但是，对于使用strictfp关键字标记的方法必须使用严格的浮点计算来生成可再生的结果。</p>\n<ul>\n<li>可以把 main 方法标记为 public static strictfp void main(String[] args)于是，在main方法中的所有指令都将使用严格的浮点计算。</li>\n<li>如果将一个类标记为 strictfp, 这个类中的所有方法都要使用严格的浮点计算。实际的计算方式将取决于 Intel 处理器的行为。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<p>在默认情况下，中间结果允许使用扩展 的指数， 但不允许使用扩展的尾数(Intel 芯片在截断尾数时并不损失性能)。 因此，这两种 方式的区别仅仅在于采用默认的方式不会产生溢出，而采用严格的计算有可能产生溢出。</p>\n</blockquote>\n<ol start=\"5\">\n<li>C++ 注释: 不要在 boolean 类型与任何数值类型之间进行强制类型转换，这样可以防止发生错误。只有极少数的情况才需要将布尔类型转换为数值类型，这时可以使用条件表达式b? 1:0</li>\n<li>不可变字符串：由于不能修改Java字符串中的字符，所以在Java文档中将String 类对象称为不可变字符串，如同数字3永远是数字3—样，字符串“ Hello”永远包含字符H、e、1、1和o的代 码单元序列，而不能修改其中的任何一个字符。</li>\n<li>char 数据类型是一 个采用 UTF-16 编码表示 Unicode 码点的代码单元。 大多数的常用 Unicode 字符使用一个代 码单元就可以表示， 而辅助字符需要一对代码单元表示。</li>\n<li><img src=\"https://i.loli.net/2019/01/21/5c453af4afdf3.png\" alt=\"image.png\"></li>\n<li>java的cmake？<blockquote>\n<p>javac Employee*.java<br>于是， 所有与通配符匹配的源文件都将被编译成类文件。 或者键人下列命令:<br>javac EmployeeTest.java<br>读者可能会感到惊讶， 使用第二种方式， 并没有显式地编译 Employeejava 然而， 当 Java 编 译器发现 EmployeeTestjava 使用了Employee 类时会查找名为 Employee.class 的文件。 如果没有找 到这个文件， 就会自动地搜索 Employeejava, 然后， 对它进行编译。更重要的是: 如果 Employee.java 版本较已有的 Employee.class 文件版本新， Java 编译器就会自动地重新编译这个文件。</p>\n</blockquote>\n</li>\n<li><code>janes.EmployeeCJames Bond&quot;, 250000, 1950, 1, 1) // ERROR</code></li>\n<li><p>所有的 Java 对象都是在堆中构造的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Employee <span class=\"title\">number007</span><span class=\"params\">(<span class=\"string\">\"]anie5 Bond\"</span>, <span class=\"number\">100000</span>, <span class=\"number\">1950</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>)</span></span>;<span class=\"comment\">//此种方式是在栈中建立</span></span><br><span class=\"line\"><span class=\"comment\">// C++, not Java</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>下面总结一下 Java 中方法参数的使用情况:         </p>\n</li>\n</ol>\n<ul>\n<li>一个方法不能修改一个基本数据类型的参数 (即数值型或布尔型)。 </li>\n<li>一个方法可以改变一个对象参数的状态。 </li>\n<li>一个方法不能让对象参数引用一个新的对象</li>\n</ul>\n<ol start=\"13\">\n<li>如果类中提供了至少一个构造器，但是没有提供无参数的构造器， 则在构造对象时如果 没有提供参数就会被视为不合法。</li>\n<li><p>初始值不一定是常量值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> nextld;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id = assignld();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> assignld&#123; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = nextld; nextld++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>java内存结构<br><a href=\"https://i.loli.net/2019/01/02/5c2b9bf995574.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://i.loli.net/2019/01/02/5c2b9bf995574.png\" alt=\"\"></a></p>\n</li>\n</ol>\n<ol start=\"16\">\n<li><p>对象初始化块（要在实例域后定义）和静态初始化块</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">static</span>) <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Some</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        a++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>import 语句不仅可以导入类，还增加了导人<code>静态方法</code>和<code>静态域</code>的功能。</p>\n</li>\n<li>标记为 public 的部分可以被任意的类使 用;标记为private的部分只能被定义它们的类使用。如果没有指定public或private,这个部分(类、方法或变量)可以被同一个包中的所有方法访问。</li>\n<li>类文件存储在文件系统的子目录中。类的路径必须与包名匹配。</li>\n<li>为了使类能够被多个程序共享， 需要做到下面几点:<blockquote>\n<ul>\n<li>把类放到一个目录中 例如 /home/user/classdir 需要注意 这个目录是包树状结构的基目录。如果希望将com.horstmann.corejava.Employee 类添加到其中， 这个 Employee.class 类文件就必须位于子目录 /home/user/classdir/com/horstmann/corejava中。</li>\n<li>将 JAR 文件放在一个目录中， 例如:/home/user/archives。</li>\n<li>设置类路径(classpath)。类路径是所有包含类文件的路径的集合。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>在 UNIX 环境中， 类路径中的不同项目之间采用冒号 (一) 分隔:<br>/home/user/classdir:.: /home/user/archives/archive .jar</li>\n<li>在 Windows 环境中， 则以分号(;)分隔:<br>c:\\classdir;.;c:\\archives\\ archive.jar</li>\n</ul>\n<ol start=\"21\">\n<li>假定虚拟机要搜寻com.horstmann.corejava.Employee 类文件。它首先要查看存储在jre/lib和jre/lib/ext目录下的归档文件中所存放的系统类文件。显然,在那里找不到相应的类文件,然后再查看类路径。然后查找以下文件:</li>\n</ol>\n<ul>\n<li>/home/user/classdir/com/horstmann/corejava/Employee.class</li>\n<li>./com/horstmann/corejava/Employee.class </li>\n<li>com/horstmann/corejava/Employee.class inside /home/user/archives/archive.jar</li>\n</ul>\n<p>编译器定位文件要比虚拟机复杂得多。如果引用了一个类，而没有指出这个类所在的包，那么编译器将首先查找包含这个类的包，并询查所有的 import 指令，确定其中是否包含了被引用的类。 例如， 假定源文件包含指令:<br><code>import java.util.*;</code><br><code>import com.horstmann.corejava.*;</code><br>并且源代码引用了 Employee 类。 编译器将试图查找 java.lang.Employee ( 因为 java.lang 包被 默认导入 )、 java.util.Employee、 com.horstmann.corejava.Employee 和当前包中的 Employee。</p>\n<ol start=\"22\">\n<li>为什么优先使用不可变类：更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改。其结果是不可预料的。如果类是不可变的，就可以安全地在多个线程间共享其对象。</li>\n<li>关键字this有两个用途：一是引用隐式参数，二是调用该类其他的构造器，同样，super关键字也有两个用途:一是调用超类的方法， 二是调用超类的构造器。</li>\n<li>JAVA多态的问题<br><img src=\"https://i.loli.net/2019/01/21/5c453b3d75180.png\" alt=\"image.png\"></li>\n<li>方法的名字和参数列表称为方法的签名</li>\n<li>下面归纳一下Java 用于控制可见性的4个访问修饰符</li>\n</ol>\n<ul>\n<li>仅对本类可见————private。</li>\n<li>对所有类可见————public。</li>\n<li>对本包和所有子类可见————protected</li>\n<li>对本包可见————默认（很遗憾)，不需要修饰符.</li>\n</ul>\n<ol start=\"27\">\n<li>为了防备name或hireDay可能为null的情况，需要使用Objects.equals 方法。</li>\n<li><p>关于equals方法</p>\n<blockquote>\n<ol>\n<li>（默认方法）Object的equals方法检测两个类是否具有相同的引用。(但我们的需求经常是连个类的状态（域）相等即为相等，但这也不绝对，所以对于一个对象怎样算相等应当具体问题具体分析)</li>\n<li>两给类的状态相等即为相等这一情况又一般分为两种情况：</li>\n</ol>\n<ul>\n<li>例如AbstractSet.equals中的equals被定义为final（实际并不是，但后续覆盖的话基本思想不变只是使算法更高效），这是由于TreeSet和HashSet的实例也应当可以相等，只要他们包含的元素一样。一般来讲（上面特例），此时对于该类的所有子类都不允许重载。(对所有的AbstractSet子类都有同样的“语义”)</li>\n<li>严格控制只有实例的class相同才可能相等。</li>\n</ul>\n<ol start=\"3\">\n<li>下面给出编写一个完美的equals 方法的建议：<br>1 ) 显式参数命名为otherObject, 稍后需要将它转换成另一个叫做other 的变量。<br>2 ) 检测this与otherObject 是否引用同一个对象：<br><code>if (this = otherObject) return true;</code><br>3 ) 检测otherObject 是否为null .<br><code>if (otherObject = null ) return false;</code><br>4 ) 比较this 与otherObject 是否属于同一个类。如果equals 的语义在每个子类中有所改变，就使用getClass 检测：<br><code>if (getClass() != otherObject.getCIass()) return false;</code><br>如果所有的子类都拥有统一的语义，就使用instanceof 检测：<br><code>if (!(otherObject instanceof ClassName)) return false;</code><br>5 ) 将otherObject 转换为相应的类类型变量：<br><code>ClassName other = (ClassName) otherObject</code><br>6 ) 现在开始对所有需要比较的域进行比较了。使用== 比较基本类型域，使用equals比<br>较对象域。如果所有的域都匹配，就返回true; 否则返回false。<br><code>return fieldl == other.field&amp;&amp; Objects.equa1s(fie1d2,</code><br><code>other.field2)</code><br><strong>如果在子类中重新定义equals</strong>,就要在其中包含调用super.equals(other)  </li>\n</ol>\n</blockquote>\n</li>\n<li><p>对于数组类型的域，可以使用静态的Arrays.equals方法检测相应的数组元素是否相等。</p>\n</li>\n</ol>\n<p>30.hashcodeAPI<br><code>int type.hashcode(type instance);</code><br><code>Objects.hash(name, salary, hireDay) ;</code><br><code>static int java.util.Arrays.hashCode(type[] a)</code><br>31.Equals 与hashCode 的定义必须一致：如果x.equals(y) 返回true, 那么x.hashCode()就必须与y.hashCode()具有相同的值。例如，如果用定义的Employee.equals比较雇员的ID，那么hashCode 方法就需要散列ID，而不是雇员的姓名或存储地址。</p>\n<ol start=\"32\">\n<li>这就是Java 中不尽如人意的参数化类型的限制所带来的结果。鉴于兼容性的考虑，编译器在对类型转换进行检査之后， 如果没有发现违反规则的现象，就将所有的类型化数组列表转换成原始ArrayList对象。在程序运行时， 所有的数组列表都是一样的，即没有虚拟机中的类型参数。因此，类型转换（ArrayList ) 和( ArrayList<employee> ) 将执行相同的运行时检查。</employee></li>\n<li>下面这个调用<br><code>list.add(3);</code><br>将自动地变换成<br><code>list.add(Integer.value0f(3)) ;</code><br>这种变换被称为<strong>自动装箱（autoboxing)</strong>。<br>int n = list.get(i);<br>翻译成<br>int n = list.get(i).intValue();<br>这种变换被称为<strong>自动拆箱（autoboxing)</strong>.<br>在算术表达式中也能够自动地装箱和拆箱：<br><code>Integer n = 3;</code><br><code>n++;</code><br>自动拆装箱是编译器操作而不是虚拟机操作，编译器在编译时添加适当方法</li>\n<li>注意区分不可变对象和可变对象。</li>\n<li><p>可以将已经存在且<strong>最后一个</strong>参数是数组的方法重新定义为可变参数的方法，而不会破坏任何已经存在的代码,Object… 参数类型与Object[] 完全一样, 当然基本类型也是可以，如下面的例子。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">double</span>... values)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> largest = Double.NECATIVEJNFINITY;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">double</span> v : values) <span class=\"keyword\">if</span> (v &gt; largest) largest = v;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> largest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>枚举：<code>public enuni Size { SMALL, MEDIUM, LARGE, EXTRAJARGE };</code><br>实际上，这个声明定义的类型是一个类， 它刚好有4 个实例， 在此尽量不要构造新对象。<br>因此， 在比较两个枚举类型的值时， 永远不需要调用equals, 而直接使用“ = =” 就<br>可以了。</p>\n</li>\n<li>枚举的复杂用法：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Size</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SMALL(<span class=\"string\">\"S\"</span>), MEDIUM(<span class=\"string\">\"M\"</span>) , LARGE(<span class=\"string\">\"L\"</span>) , EXTRA_LARGE(<span class=\"string\">\"XL\"</span>);<span class=\"comment\">//只有四个对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String abbreviation;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Size</span><span class=\"params\">(String abbreviation)</span> </span>&#123; <span class=\"keyword\">this</span>,abbreviation = abbreviation; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getAbbreviation</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> abbreviation; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><code>Size s = Enum.valueOf(Size.class, &quot;SMALL&quot;);</code><br><code>Size[] Size.values()</code></p>\n<ol start=\"38\">\n<li>反射<blockquote>\n<p><code>Class cl = Cl ass.forName(className) ;</code><br>鉴于历史原getName 方法在应用于数组类型的时候会返回一个很奇怪的名字：<br>• Double[] class.getName() 返回“ [Ljava.lang.Double; ’’<br>• int[].class.getName()返回“ [I ” ，<br>虚拟机为每个类型管理一个Class对象。因此， 可以利用=运算符实现两个类对象比较的操作<br>Class 类的getDeclareFields、getDeclareMethods和getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器， 其中包括私有和受保护成员，但不包括超类的成员。</p>\n</blockquote>\n</li>\n</ol>\n<ol start=\"39\">\n<li><p>Java 数组会记住每个元素的类型， 即创建数组时new 表达式中使用的元素类型。将一个Employee[ ]临时地转换成Object[ ] 数组， 然后再把它转换回来是可以的，但一从开始就是Objectt ] 的数组却永远不能转换成Employe [] 数组。<br>下面是java.util.Arrays.copyof的实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">badCopyOf</span><span class=\"params\">(Object[] a, <span class=\"keyword\">int</span> newLength)</span> <span class=\"comment\">// not useful</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ObjectD newArray = <span class=\"keyword\">new</span> Object[newlength]:</span><br><span class=\"line\">    System.arraycopy(a, <span class=\"number\">0</span>, newArray, <span class=\"number\">0</span>, Math.min(a.length, newLength)) ;</span><br><span class=\"line\">    <span class=\"comment\">//注意这个方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> newArray;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">goodCopyOf</span><span class=\"params\">(Object a, <span class=\"keyword\">int</span> newLength)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Class cl = a.getClass()；</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (！cl.isArray()) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span> ;</span><br><span class=\"line\">    Class componentType = cl.getComponentType()；<span class=\"comment\">//注意</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = Array.getLength(a);</span><br><span class=\"line\">    Object newArray = Array.newlnstance(componentType, newLength) :<span class=\"comment\">//注意 java.lang.Array</span></span><br><span class=\"line\">    System.arraycopy(a, <span class=\"number\">0</span>, newArray, <span class=\"number\">0</span>, Math.min(length, newLength)) ;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>调用任意方法<br><code>Object invoke(Object obj, Object... args)</code> 如果是静态方法obj填null</p>\n</li>\n<li>虽然在接口中不能包含实例域或<strong>静态方法(java8之前)</strong>，但却可以包含常量.</li>\n<li>目前为止， 通常的做法都是将静态方法放在伴随类中。在标准库中， 你会看到成对出现<br>的接口和实用工具类， 如Collection/Collections 或Path/Paths。面来看Paths 类， 其中只包含两个工厂方法。可以由一个字符串序列构造一个文件或目录的路径， 如Paths.get(“jdk1.8.0”, “jre”, “bin”)。在Java SE 8中， 可以为Path 接口增加以下方法：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Path</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Path <span class=\"title\">get</span><span class=\"params\">(String first, String... more)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Fi1eSystems.getDefault().getPath(first, more);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这样一来， Paths 类就不再是必要的了。</p>\n<ol start=\"43\">\n<li>default关键字：用于接口中方法的声明，意为接口中的实现为默认实现，如果实现接口的类不覆盖则使用这个实现。</li>\n<li>默认方法的一个重要用法是“接口演化” （interface evolution)。</li>\n<li>我们只讨论了两个接口的命名冲突。现在来考虑另一种情况，一个类扩展了一个超类，同时实现了一个接口，并从超类和接口继承了相同的方法。例如，假设Person 是一个类，Student 定义为：class Student extends Person implements Named { . . . }在这种情况下， 只会考虑超类方法， 接口的所有默认方法都会被忽略。在我们的例子中， Student从Person继承了getName方法，Named接口是否为getName提供了默认实现并不会带来什么区别。这正是“ 类优先” 规则。</li>\n<li>尽管LengthComparator对象没有状态，不过还是需要建立这个对象的一个实例。我们需要这个实例来调用compare方法，它不是一个静态方法。</li>\n<li>通常子对象都是可变的，必须重新定义clone方法来建立一个深拷贝，同时克隆所有子对象。在这个例子中，hireDay域是一个Date,这是可变的，所以它也需要克隆。（出于这个原因，这个例子使用Date类型的域而不是LocalDate来展示克隆过程。如果hireDay是不可变的LocalDate类的一个实例，就无需我们做任何处理了。）<br><img src=\"https://i.loli.net/2019/01/21/5c453bea3e69d.png\" alt=\"image.png\"></li>\n<li>Cloneable 接口是Java提供的一组标记接口(tagging interface) 之一<br>标记接口不包含任何方法；它唯一的作用就是允许在类型查询中使用instanceof。即使clone的默认（浅拷贝）实现能够满足要求（实例域全部是不可变时），还是需要实现Cloneable接口，将clone重新定义为public， 再调用super.clone()。</li>\n<li>如果在一个对象上调用clone,但这个对象的类并没有实现Cloneable接口，Object 类的clone方法就会拋出一个CloneNotSupportedException当然，Employee和Date类实现了Cloneable 接口，所以不会抛出这个异常。不过，编译器并不了解这一点，因此，我们声明了这个异常。</li>\n<li>所有数组类型都有一个public的clone 方法，而不是protected,可以用这个方法<br>建立一个新数组，包含原数组所有元素的副本。</li>\n<li>对于只有一个抽象方法的接口， 需要这种接口的对象时，就可以提供一个lambda 表达式。这种接口称为函数式接口（ functional interface )。</li>\n<li>甚至不能把lambda表达式赋给类型为Object的变量，Object不是一个函数式接口。</li>\n<li><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.util.function 包中有一个尤其有用的接口Predicate:</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Predicate</span>&lt;<span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">test</span><span class=\"params\">(T t)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// Additional default and static methods</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ArrayList 类有一个removelf 方法， 它的参数就是一个Predicate。这个接口专门用来传递</span><br><span class=\"line\">lambda 表达式。例如，下面的语句将从一个数组列表删除所有<span class=\"keyword\">null</span>值：</span><br><span class=\"line\">list.removelf(e -&gt; e == <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法引用：一种lambda表达式简化方式，根据lamdba表达式所在的函数式接口的位置，确定</p>\n<blockquote>\n<p>从这些例子可以看出， 要用::操作符分隔方法名与对象或类名。主要有3 种情况：</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>object::instanceMethod</li>\n<li>Class::staticMethod</li>\n<li>Class::instanceMethod<br>在前2 种情况中， 方法引用等价于提供方法参数的lambda 表达式。前面已经提到，<br>System.out::println 等价于x -&gt; System.out.println(x)。 类似地，Math::pow 等价于（x，y) -&gt;Math.pow(x, y)。<br>对于第3 种情况， 第1个参数会成为方法的目标。例如，String::compareToIgnoreCase 等同于(x, y) -&gt; x.compareToIgnoreCase(y);</li>\n</ul>\n<ol start=\"55\">\n<li>lambda 表达式中捕获的变量必须实际上是<strong>最终变量( effectivelyfinal)</strong>。实际上的最终变量是指， 这个变量初始化之后就不会再为它赋新值。在这里，text 总是指示同一个 String对象，所以捕获这个变量是合法的。不过，i的值会改变，因此不能捕获i。</li>\n<li>内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域.为了能够运行这个程序，内部类的对象总有一个隐式引用，它指向了创建它的外部类对象。</li>\n<li>TimePrinter 类声明为私有的。这样一来，只有TalkingClock的方法才能够构造TimePrinter 对象。只有内部类可以是私有类，而常规类只可以具有包可见性，或公有可见性。</li>\n<li>外围类，内部类。</li>\n<li>使用静态内部类的原因，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。为此，可以将内部类声明为static,以便取消产生的引用。</li>\n<li>这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用，对于用程序设计人员来说，遇到这种情况的机会很少。</li>\n<li>“ 如果出现RuntimeException 异常， 那么就一定是你的问题” 是一条相当有道理的规则。<br>应该通过检测数组下标是否越界来避免ArraylndexOutOfBoundsException 异常；应该通过在使用变量之前检测是否为null来杜绝NullPointerException异常的发生：</li>\n<li>前面曾经提到过：如果编写一个覆盖超类的方法，而这个方法又没有抛出异常（如JComponent中的paintComponent),那么这个方法就必须捕获方法代码中出现的每一个受查异常。不许在子类的throws 说明符中出现超过超类方法所列出的异常类范围。</li>\n<li>catch (FileNotFoundException | UnknownHostException e) { . . . }</li>\n<li><p>同样，也不应该声明从RuntimeException 继承的那些非受查异常.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAnimation</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">drawlmage</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> <span class=\"keyword\">throws</span> ArraylndexOutOfBoundsException <span class=\"comment\">// bad style</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>未被任何变量引用的日志记录器可能会被垃圾回收。为了防止这种情况发生，要像上面的例子中一样，用一个静态变量存储日志记录器的一个引用。</p>\n</li>\n</ol>\n<h2 id=\"JAVA和C-的区别\"><a href=\"#JAVA和C-的区别\" class=\"headerlink\" title=\"JAVA和C++的区别\"></a>JAVA和C++的区别</h2><table>\n<thead>\n<tr>\n<th>什么方面</th>\n<th>JAVA</th>\n<th>C++</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>类中函数</td>\n<td>方法</td>\n<td>成员函数</td>\n<td></td>\n</tr>\n<tr>\n<td>字面数值表示</td>\n<td>可以加下划线</td>\n<td>不可以</td>\n<td></td>\n</tr>\n<tr>\n<td>进制表示</td>\n<td>可表示二进制（0b或0B）</td>\n<td>不可以</td>\n<td></td>\n</tr>\n<tr>\n<td>无符号数</td>\n<td>没有</td>\n<td>有</td>\n<td></td>\n</tr>\n<tr>\n<td>逗号运算符</td>\n<td>没有</td>\n<td>有</td>\n<td></td>\n</tr>\n<tr>\n<td>更改器方法与访问器方法</td>\n<td>无明显区别</td>\n<td>const关键字</td>\n<td></td>\n</tr>\n<tr>\n<td>方法参数</td>\n<td>按值（引用也是按值）</td>\n<td>真引用（换个名字）</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"<h1 id=\"Java-语言学习笔记\"><a href=\"#Java-语言学习笔记\" class=\"headerlink\" title=\"Java 语言学习笔记\"></a>Java 语言学习笔记</h1><h2 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h2><p>更改器方法与访问器方法 实例域<br>方法参数(基本&amp;引用) 静态域<br>不可变类，可变类<br>对象包装器<br>handler 处理器<br>已检查异常，和未检查异常<br>实用工具方法<br>","more":"</p>\n<h2 id=\"零碎知识\"><a href=\"#零碎知识\" class=\"headerlink\" title=\"零碎知识\"></a>零碎知识</h2><ol>\n<li>main 函数必须是public的</li>\n<li>final 定义变量 等于 const（C/C++）</li>\n<li>static final 用于一个常量在一个类中多个方法使用.（public static final 其他类类使用）</li>\n<li>strictfp关键字<blockquote>\n<p>可移植性是Java语言的设计目标之一， 无论在哪个虚拟机上运行，同一运算应该得到同样的结果,对于浮点数的算术运算，实现这样的可移植性是相当困难。double类型使用 64 位存储一个数值，而有些处理器使用80位浮点寄存器,这些寄存器增加了中间过程的计算精度. 但是，这个结果可能与始终在64位机器上计算的结果不一样。因此， Java 虚拟机的最初规范规定所有的中间计算都必须进行截断这种行为遭到了数值计算团体的反对。 截断计算不仅可能导致溢出，而且由于截断操作需要消耗时间，所以在计算速度上实际上要比精确计算慢。 为此，Java承认了最优性能与理想结果之间存在的冲突，并给予了改进。在默认情况下，虚拟机设计者允许对中间计算结果采用扩展的精度。但是，对于使用strictfp关键字标记的方法必须使用严格的浮点计算来生成可再生的结果。</p>\n<ul>\n<li>可以把 main 方法标记为 public static strictfp void main(String[] args)于是，在main方法中的所有指令都将使用严格的浮点计算。</li>\n<li>如果将一个类标记为 strictfp, 这个类中的所有方法都要使用严格的浮点计算。实际的计算方式将取决于 Intel 处理器的行为。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<p>在默认情况下，中间结果允许使用扩展 的指数， 但不允许使用扩展的尾数(Intel 芯片在截断尾数时并不损失性能)。 因此，这两种 方式的区别仅仅在于采用默认的方式不会产生溢出，而采用严格的计算有可能产生溢出。</p>\n</blockquote>\n<ol start=\"5\">\n<li>C++ 注释: 不要在 boolean 类型与任何数值类型之间进行强制类型转换，这样可以防止发生错误。只有极少数的情况才需要将布尔类型转换为数值类型，这时可以使用条件表达式b? 1:0</li>\n<li>不可变字符串：由于不能修改Java字符串中的字符，所以在Java文档中将String 类对象称为不可变字符串，如同数字3永远是数字3—样，字符串“ Hello”永远包含字符H、e、1、1和o的代 码单元序列，而不能修改其中的任何一个字符。</li>\n<li>char 数据类型是一 个采用 UTF-16 编码表示 Unicode 码点的代码单元。 大多数的常用 Unicode 字符使用一个代 码单元就可以表示， 而辅助字符需要一对代码单元表示。</li>\n<li><img src=\"https://i.loli.net/2019/01/21/5c453af4afdf3.png\" alt=\"image.png\"></li>\n<li>java的cmake？<blockquote>\n<p>javac Employee*.java<br>于是， 所有与通配符匹配的源文件都将被编译成类文件。 或者键人下列命令:<br>javac EmployeeTest.java<br>读者可能会感到惊讶， 使用第二种方式， 并没有显式地编译 Employeejava 然而， 当 Java 编 译器发现 EmployeeTestjava 使用了Employee 类时会查找名为 Employee.class 的文件。 如果没有找 到这个文件， 就会自动地搜索 Employeejava, 然后， 对它进行编译。更重要的是: 如果 Employee.java 版本较已有的 Employee.class 文件版本新， Java 编译器就会自动地重新编译这个文件。</p>\n</blockquote>\n</li>\n<li><code>janes.EmployeeCJames Bond&quot;, 250000, 1950, 1, 1) // ERROR</code></li>\n<li><p>所有的 Java 对象都是在堆中构造的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Employee <span class=\"title\">number007</span><span class=\"params\">(<span class=\"string\">\"]anie5 Bond\"</span>, <span class=\"number\">100000</span>, <span class=\"number\">1950</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>)</span></span>;<span class=\"comment\">//此种方式是在栈中建立</span></span><br><span class=\"line\"><span class=\"comment\">// C++, not Java</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>下面总结一下 Java 中方法参数的使用情况:         </p>\n</li>\n</ol>\n<ul>\n<li>一个方法不能修改一个基本数据类型的参数 (即数值型或布尔型)。 </li>\n<li>一个方法可以改变一个对象参数的状态。 </li>\n<li>一个方法不能让对象参数引用一个新的对象</li>\n</ul>\n<ol start=\"13\">\n<li>如果类中提供了至少一个构造器，但是没有提供无参数的构造器， 则在构造对象时如果 没有提供参数就会被视为不合法。</li>\n<li><p>初始值不一定是常量值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> nextld;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id = assignld();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> assignld&#123; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = nextld; nextld++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>java内存结构<br><a href=\"https://i.loli.net/2019/01/02/5c2b9bf995574.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://i.loli.net/2019/01/02/5c2b9bf995574.png\" alt=\"\"></a></p>\n</li>\n</ol>\n<ol start=\"16\">\n<li><p>对象初始化块（要在实例域后定义）和静态初始化块</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">static</span>) <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Some</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        a++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>import 语句不仅可以导入类，还增加了导人<code>静态方法</code>和<code>静态域</code>的功能。</p>\n</li>\n<li>标记为 public 的部分可以被任意的类使 用;标记为private的部分只能被定义它们的类使用。如果没有指定public或private,这个部分(类、方法或变量)可以被同一个包中的所有方法访问。</li>\n<li>类文件存储在文件系统的子目录中。类的路径必须与包名匹配。</li>\n<li>为了使类能够被多个程序共享， 需要做到下面几点:<blockquote>\n<ul>\n<li>把类放到一个目录中 例如 /home/user/classdir 需要注意 这个目录是包树状结构的基目录。如果希望将com.horstmann.corejava.Employee 类添加到其中， 这个 Employee.class 类文件就必须位于子目录 /home/user/classdir/com/horstmann/corejava中。</li>\n<li>将 JAR 文件放在一个目录中， 例如:/home/user/archives。</li>\n<li>设置类路径(classpath)。类路径是所有包含类文件的路径的集合。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>在 UNIX 环境中， 类路径中的不同项目之间采用冒号 (一) 分隔:<br>/home/user/classdir:.: /home/user/archives/archive .jar</li>\n<li>在 Windows 环境中， 则以分号(;)分隔:<br>c:\\classdir;.;c:\\archives\\ archive.jar</li>\n</ul>\n<ol start=\"21\">\n<li>假定虚拟机要搜寻com.horstmann.corejava.Employee 类文件。它首先要查看存储在jre/lib和jre/lib/ext目录下的归档文件中所存放的系统类文件。显然,在那里找不到相应的类文件,然后再查看类路径。然后查找以下文件:</li>\n</ol>\n<ul>\n<li>/home/user/classdir/com/horstmann/corejava/Employee.class</li>\n<li>./com/horstmann/corejava/Employee.class </li>\n<li>com/horstmann/corejava/Employee.class inside /home/user/archives/archive.jar</li>\n</ul>\n<p>编译器定位文件要比虚拟机复杂得多。如果引用了一个类，而没有指出这个类所在的包，那么编译器将首先查找包含这个类的包，并询查所有的 import 指令，确定其中是否包含了被引用的类。 例如， 假定源文件包含指令:<br><code>import java.util.*;</code><br><code>import com.horstmann.corejava.*;</code><br>并且源代码引用了 Employee 类。 编译器将试图查找 java.lang.Employee ( 因为 java.lang 包被 默认导入 )、 java.util.Employee、 com.horstmann.corejava.Employee 和当前包中的 Employee。</p>\n<ol start=\"22\">\n<li>为什么优先使用不可变类：更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改。其结果是不可预料的。如果类是不可变的，就可以安全地在多个线程间共享其对象。</li>\n<li>关键字this有两个用途：一是引用隐式参数，二是调用该类其他的构造器，同样，super关键字也有两个用途:一是调用超类的方法， 二是调用超类的构造器。</li>\n<li>JAVA多态的问题<br><img src=\"https://i.loli.net/2019/01/21/5c453b3d75180.png\" alt=\"image.png\"></li>\n<li>方法的名字和参数列表称为方法的签名</li>\n<li>下面归纳一下Java 用于控制可见性的4个访问修饰符</li>\n</ol>\n<ul>\n<li>仅对本类可见————private。</li>\n<li>对所有类可见————public。</li>\n<li>对本包和所有子类可见————protected</li>\n<li>对本包可见————默认（很遗憾)，不需要修饰符.</li>\n</ul>\n<ol start=\"27\">\n<li>为了防备name或hireDay可能为null的情况，需要使用Objects.equals 方法。</li>\n<li><p>关于equals方法</p>\n<blockquote>\n<ol>\n<li>（默认方法）Object的equals方法检测两个类是否具有相同的引用。(但我们的需求经常是连个类的状态（域）相等即为相等，但这也不绝对，所以对于一个对象怎样算相等应当具体问题具体分析)</li>\n<li>两给类的状态相等即为相等这一情况又一般分为两种情况：</li>\n</ol>\n<ul>\n<li>例如AbstractSet.equals中的equals被定义为final（实际并不是，但后续覆盖的话基本思想不变只是使算法更高效），这是由于TreeSet和HashSet的实例也应当可以相等，只要他们包含的元素一样。一般来讲（上面特例），此时对于该类的所有子类都不允许重载。(对所有的AbstractSet子类都有同样的“语义”)</li>\n<li>严格控制只有实例的class相同才可能相等。</li>\n</ul>\n<ol start=\"3\">\n<li>下面给出编写一个完美的equals 方法的建议：<br>1 ) 显式参数命名为otherObject, 稍后需要将它转换成另一个叫做other 的变量。<br>2 ) 检测this与otherObject 是否引用同一个对象：<br><code>if (this = otherObject) return true;</code><br>3 ) 检测otherObject 是否为null .<br><code>if (otherObject = null ) return false;</code><br>4 ) 比较this 与otherObject 是否属于同一个类。如果equals 的语义在每个子类中有所改变，就使用getClass 检测：<br><code>if (getClass() != otherObject.getCIass()) return false;</code><br>如果所有的子类都拥有统一的语义，就使用instanceof 检测：<br><code>if (!(otherObject instanceof ClassName)) return false;</code><br>5 ) 将otherObject 转换为相应的类类型变量：<br><code>ClassName other = (ClassName) otherObject</code><br>6 ) 现在开始对所有需要比较的域进行比较了。使用== 比较基本类型域，使用equals比<br>较对象域。如果所有的域都匹配，就返回true; 否则返回false。<br><code>return fieldl == other.field&amp;&amp; Objects.equa1s(fie1d2,</code><br><code>other.field2)</code><br><strong>如果在子类中重新定义equals</strong>,就要在其中包含调用super.equals(other)  </li>\n</ol>\n</blockquote>\n</li>\n<li><p>对于数组类型的域，可以使用静态的Arrays.equals方法检测相应的数组元素是否相等。</p>\n</li>\n</ol>\n<p>30.hashcodeAPI<br><code>int type.hashcode(type instance);</code><br><code>Objects.hash(name, salary, hireDay) ;</code><br><code>static int java.util.Arrays.hashCode(type[] a)</code><br>31.Equals 与hashCode 的定义必须一致：如果x.equals(y) 返回true, 那么x.hashCode()就必须与y.hashCode()具有相同的值。例如，如果用定义的Employee.equals比较雇员的ID，那么hashCode 方法就需要散列ID，而不是雇员的姓名或存储地址。</p>\n<ol start=\"32\">\n<li>这就是Java 中不尽如人意的参数化类型的限制所带来的结果。鉴于兼容性的考虑，编译器在对类型转换进行检査之后， 如果没有发现违反规则的现象，就将所有的类型化数组列表转换成原始ArrayList对象。在程序运行时， 所有的数组列表都是一样的，即没有虚拟机中的类型参数。因此，类型转换（ArrayList ) 和( ArrayList<employee> ) 将执行相同的运行时检查。</employee></li>\n<li>下面这个调用<br><code>list.add(3);</code><br>将自动地变换成<br><code>list.add(Integer.value0f(3)) ;</code><br>这种变换被称为<strong>自动装箱（autoboxing)</strong>。<br>int n = list.get(i);<br>翻译成<br>int n = list.get(i).intValue();<br>这种变换被称为<strong>自动拆箱（autoboxing)</strong>.<br>在算术表达式中也能够自动地装箱和拆箱：<br><code>Integer n = 3;</code><br><code>n++;</code><br>自动拆装箱是编译器操作而不是虚拟机操作，编译器在编译时添加适当方法</li>\n<li>注意区分不可变对象和可变对象。</li>\n<li><p>可以将已经存在且<strong>最后一个</strong>参数是数组的方法重新定义为可变参数的方法，而不会破坏任何已经存在的代码,Object… 参数类型与Object[] 完全一样, 当然基本类型也是可以，如下面的例子。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">double</span>... values)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> largest = Double.NECATIVEJNFINITY;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">double</span> v : values) <span class=\"keyword\">if</span> (v &gt; largest) largest = v;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> largest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>枚举：<code>public enuni Size { SMALL, MEDIUM, LARGE, EXTRAJARGE };</code><br>实际上，这个声明定义的类型是一个类， 它刚好有4 个实例， 在此尽量不要构造新对象。<br>因此， 在比较两个枚举类型的值时， 永远不需要调用equals, 而直接使用“ = =” 就<br>可以了。</p>\n</li>\n<li>枚举的复杂用法：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Size</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SMALL(<span class=\"string\">\"S\"</span>), MEDIUM(<span class=\"string\">\"M\"</span>) , LARGE(<span class=\"string\">\"L\"</span>) , EXTRA_LARGE(<span class=\"string\">\"XL\"</span>);<span class=\"comment\">//只有四个对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String abbreviation;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Size</span><span class=\"params\">(String abbreviation)</span> </span>&#123; <span class=\"keyword\">this</span>,abbreviation = abbreviation; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getAbbreviation</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> abbreviation; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><code>Size s = Enum.valueOf(Size.class, &quot;SMALL&quot;);</code><br><code>Size[] Size.values()</code></p>\n<ol start=\"38\">\n<li>反射<blockquote>\n<p><code>Class cl = Cl ass.forName(className) ;</code><br>鉴于历史原getName 方法在应用于数组类型的时候会返回一个很奇怪的名字：<br>• Double[] class.getName() 返回“ [Ljava.lang.Double; ’’<br>• int[].class.getName()返回“ [I ” ，<br>虚拟机为每个类型管理一个Class对象。因此， 可以利用=运算符实现两个类对象比较的操作<br>Class 类的getDeclareFields、getDeclareMethods和getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器， 其中包括私有和受保护成员，但不包括超类的成员。</p>\n</blockquote>\n</li>\n</ol>\n<ol start=\"39\">\n<li><p>Java 数组会记住每个元素的类型， 即创建数组时new 表达式中使用的元素类型。将一个Employee[ ]临时地转换成Object[ ] 数组， 然后再把它转换回来是可以的，但一从开始就是Objectt ] 的数组却永远不能转换成Employe [] 数组。<br>下面是java.util.Arrays.copyof的实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">badCopyOf</span><span class=\"params\">(Object[] a, <span class=\"keyword\">int</span> newLength)</span> <span class=\"comment\">// not useful</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ObjectD newArray = <span class=\"keyword\">new</span> Object[newlength]:</span><br><span class=\"line\">    System.arraycopy(a, <span class=\"number\">0</span>, newArray, <span class=\"number\">0</span>, Math.min(a.length, newLength)) ;</span><br><span class=\"line\">    <span class=\"comment\">//注意这个方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> newArray;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">goodCopyOf</span><span class=\"params\">(Object a, <span class=\"keyword\">int</span> newLength)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Class cl = a.getClass()；</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (！cl.isArray()) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span> ;</span><br><span class=\"line\">    Class componentType = cl.getComponentType()；<span class=\"comment\">//注意</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = Array.getLength(a);</span><br><span class=\"line\">    Object newArray = Array.newlnstance(componentType, newLength) :<span class=\"comment\">//注意 java.lang.Array</span></span><br><span class=\"line\">    System.arraycopy(a, <span class=\"number\">0</span>, newArray, <span class=\"number\">0</span>, Math.min(length, newLength)) ;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>调用任意方法<br><code>Object invoke(Object obj, Object... args)</code> 如果是静态方法obj填null</p>\n</li>\n<li>虽然在接口中不能包含实例域或<strong>静态方法(java8之前)</strong>，但却可以包含常量.</li>\n<li>目前为止， 通常的做法都是将静态方法放在伴随类中。在标准库中， 你会看到成对出现<br>的接口和实用工具类， 如Collection/Collections 或Path/Paths。面来看Paths 类， 其中只包含两个工厂方法。可以由一个字符串序列构造一个文件或目录的路径， 如Paths.get(“jdk1.8.0”, “jre”, “bin”)。在Java SE 8中， 可以为Path 接口增加以下方法：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Path</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Path <span class=\"title\">get</span><span class=\"params\">(String first, String... more)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Fi1eSystems.getDefault().getPath(first, more);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这样一来， Paths 类就不再是必要的了。</p>\n<ol start=\"43\">\n<li>default关键字：用于接口中方法的声明，意为接口中的实现为默认实现，如果实现接口的类不覆盖则使用这个实现。</li>\n<li>默认方法的一个重要用法是“接口演化” （interface evolution)。</li>\n<li>我们只讨论了两个接口的命名冲突。现在来考虑另一种情况，一个类扩展了一个超类，同时实现了一个接口，并从超类和接口继承了相同的方法。例如，假设Person 是一个类，Student 定义为：class Student extends Person implements Named { . . . }在这种情况下， 只会考虑超类方法， 接口的所有默认方法都会被忽略。在我们的例子中， Student从Person继承了getName方法，Named接口是否为getName提供了默认实现并不会带来什么区别。这正是“ 类优先” 规则。</li>\n<li>尽管LengthComparator对象没有状态，不过还是需要建立这个对象的一个实例。我们需要这个实例来调用compare方法，它不是一个静态方法。</li>\n<li>通常子对象都是可变的，必须重新定义clone方法来建立一个深拷贝，同时克隆所有子对象。在这个例子中，hireDay域是一个Date,这是可变的，所以它也需要克隆。（出于这个原因，这个例子使用Date类型的域而不是LocalDate来展示克隆过程。如果hireDay是不可变的LocalDate类的一个实例，就无需我们做任何处理了。）<br><img src=\"https://i.loli.net/2019/01/21/5c453bea3e69d.png\" alt=\"image.png\"></li>\n<li>Cloneable 接口是Java提供的一组标记接口(tagging interface) 之一<br>标记接口不包含任何方法；它唯一的作用就是允许在类型查询中使用instanceof。即使clone的默认（浅拷贝）实现能够满足要求（实例域全部是不可变时），还是需要实现Cloneable接口，将clone重新定义为public， 再调用super.clone()。</li>\n<li>如果在一个对象上调用clone,但这个对象的类并没有实现Cloneable接口，Object 类的clone方法就会拋出一个CloneNotSupportedException当然，Employee和Date类实现了Cloneable 接口，所以不会抛出这个异常。不过，编译器并不了解这一点，因此，我们声明了这个异常。</li>\n<li>所有数组类型都有一个public的clone 方法，而不是protected,可以用这个方法<br>建立一个新数组，包含原数组所有元素的副本。</li>\n<li>对于只有一个抽象方法的接口， 需要这种接口的对象时，就可以提供一个lambda 表达式。这种接口称为函数式接口（ functional interface )。</li>\n<li>甚至不能把lambda表达式赋给类型为Object的变量，Object不是一个函数式接口。</li>\n<li><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.util.function 包中有一个尤其有用的接口Predicate:</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Predicate</span>&lt;<span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">test</span><span class=\"params\">(T t)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// Additional default and static methods</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ArrayList 类有一个removelf 方法， 它的参数就是一个Predicate。这个接口专门用来传递</span><br><span class=\"line\">lambda 表达式。例如，下面的语句将从一个数组列表删除所有<span class=\"keyword\">null</span>值：</span><br><span class=\"line\">list.removelf(e -&gt; e == <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法引用：一种lambda表达式简化方式，根据lamdba表达式所在的函数式接口的位置，确定</p>\n<blockquote>\n<p>从这些例子可以看出， 要用::操作符分隔方法名与对象或类名。主要有3 种情况：</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>object::instanceMethod</li>\n<li>Class::staticMethod</li>\n<li>Class::instanceMethod<br>在前2 种情况中， 方法引用等价于提供方法参数的lambda 表达式。前面已经提到，<br>System.out::println 等价于x -&gt; System.out.println(x)。 类似地，Math::pow 等价于（x，y) -&gt;Math.pow(x, y)。<br>对于第3 种情况， 第1个参数会成为方法的目标。例如，String::compareToIgnoreCase 等同于(x, y) -&gt; x.compareToIgnoreCase(y);</li>\n</ul>\n<ol start=\"55\">\n<li>lambda 表达式中捕获的变量必须实际上是<strong>最终变量( effectivelyfinal)</strong>。实际上的最终变量是指， 这个变量初始化之后就不会再为它赋新值。在这里，text 总是指示同一个 String对象，所以捕获这个变量是合法的。不过，i的值会改变，因此不能捕获i。</li>\n<li>内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域.为了能够运行这个程序，内部类的对象总有一个隐式引用，它指向了创建它的外部类对象。</li>\n<li>TimePrinter 类声明为私有的。这样一来，只有TalkingClock的方法才能够构造TimePrinter 对象。只有内部类可以是私有类，而常规类只可以具有包可见性，或公有可见性。</li>\n<li>外围类，内部类。</li>\n<li>使用静态内部类的原因，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。为此，可以将内部类声明为static,以便取消产生的引用。</li>\n<li>这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用，对于用程序设计人员来说，遇到这种情况的机会很少。</li>\n<li>“ 如果出现RuntimeException 异常， 那么就一定是你的问题” 是一条相当有道理的规则。<br>应该通过检测数组下标是否越界来避免ArraylndexOutOfBoundsException 异常；应该通过在使用变量之前检测是否为null来杜绝NullPointerException异常的发生：</li>\n<li>前面曾经提到过：如果编写一个覆盖超类的方法，而这个方法又没有抛出异常（如JComponent中的paintComponent),那么这个方法就必须捕获方法代码中出现的每一个受查异常。不许在子类的throws 说明符中出现超过超类方法所列出的异常类范围。</li>\n<li>catch (FileNotFoundException | UnknownHostException e) { . . . }</li>\n<li><p>同样，也不应该声明从RuntimeException 继承的那些非受查异常.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAnimation</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">drawlmage</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> <span class=\"keyword\">throws</span> ArraylndexOutOfBoundsException <span class=\"comment\">// bad style</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>未被任何变量引用的日志记录器可能会被垃圾回收。为了防止这种情况发生，要像上面的例子中一样，用一个静态变量存储日志记录器的一个引用。</p>\n</li>\n</ol>\n<h2 id=\"JAVA和C-的区别\"><a href=\"#JAVA和C-的区别\" class=\"headerlink\" title=\"JAVA和C++的区别\"></a>JAVA和C++的区别</h2><table>\n<thead>\n<tr>\n<th>什么方面</th>\n<th>JAVA</th>\n<th>C++</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>类中函数</td>\n<td>方法</td>\n<td>成员函数</td>\n<td></td>\n</tr>\n<tr>\n<td>字面数值表示</td>\n<td>可以加下划线</td>\n<td>不可以</td>\n<td></td>\n</tr>\n<tr>\n<td>进制表示</td>\n<td>可表示二进制（0b或0B）</td>\n<td>不可以</td>\n<td></td>\n</tr>\n<tr>\n<td>无符号数</td>\n<td>没有</td>\n<td>有</td>\n<td></td>\n</tr>\n<tr>\n<td>逗号运算符</td>\n<td>没有</td>\n<td>有</td>\n<td></td>\n</tr>\n<tr>\n<td>更改器方法与访问器方法</td>\n<td>无明显区别</td>\n<td>const关键字</td>\n<td></td>\n</tr>\n<tr>\n<td>方法参数</td>\n<td>按值（引用也是按值）</td>\n<td>真引用（换个名字）</td>\n</tr>\n</tbody>\n</table>"},{"title":"Java刷题错题以及收集的Java零碎知识。","originContent":"# 错题\n1. 关于以下application,说法正确是什么？\n\n```java\npublic class Test {\n    static int x=10;\n    static {x+=5;}\n    public static void main(String[] args) //4\n        {\n        System.out.println(\"x=\"+x);\n    }\n    static{x/=3;};\n}//9\n```\n\n> 答案：编译通过，执行结果是：x=5\n\n解析：\n```java\nclass A{\n    static {\n        System.out.println(\"父类静态代码块\");\n    }\n    public A(){\n        System.out.println(\"父类构造方法\");\n    }\n    {\n        System.out.println(\"父类初始化块\");\n    }\n}\npublic class B extends A{\n    static{\n        System.out.println(\"子类静态代码块\");\n    }\n    public B(){\n        System.out.println(\"子类构造方法\");\n    }\n    {\n        System.out.println(\"子类初始化块\");\n    }\n    public static void main(String[] args){\n        new B();\n    }\n}\n```\n父类静态代码块-->子类静态代码块-->父类普通代码块-->父类构造方法-->子类代码块-->子类构造方法；\n<!-- more -->\n2.下面代码的输出是什么？\n```java\npublic class Base\n{\n    private String baseName = \"base\";\n    public Base()\n    {\n        callName();\n    }\n \n    public void callName()\n    {\n        System. out. println(baseName);\n    }\n \n    static class Sub extends Base\n    {\n        private String baseName = \"sub\";\n        public void callName()\n        {\n            System. out. println (baseName) ;\n        }\n    }\n    public static void main(String[] args)\n    {\n        Base b = new Sub();\n    }\n} \n```\n答案\n> null\n\n解析：\n>new Sub();在创造派生类的过程中首先创建基类对象，然后才能创建派生类。\n创建基类即默认调用Base()方法，在方法中调用callName()方法，由于派生类中存在此方法，则被调用的callName（）方法是派生类中的方法，此时派生类还未构造，所以变量baseName的值为null.\n\n3. Java语言中，如果\"xyz\"没有被创建过，String s = new String(“xyz”);创建了几个string对象？\n\n> 答案：2个\n\n> 解析:\n**相关知识点**：\n类加载对一个类只会进行一次。\n\"xyz\" 在类加载时就已经创建并驻留了（如果该类被加载之前已经有 \"xyz\" 字符串被驻留过则不需要重复创建用于驻留的\"xyz\"实例>）。\n\n> 驻留的字符串是放在全局共享的字符串常量池中的。\n\n> 在 HotSpot VM 里实现的 string pool 功能的是一个 StringTable 类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身）\n也就是说在堆中的某些字符串实例被这个 StringTable 引用之后就等同被赋予了”驻留字符串”的身份。\n这个 StringTable 在每个 HotSpot VM 的实例只有一份，被所有的类共享。\n\n> 在这段代码后续被运行的时候，\"xyz\" 字面量对应的 String 实例已经固定了(前面的类加载过程)，不会再被重复创建。\n\n> 所以这段代码将常量池中的对象复制一份放到 heap 中，并且把 heap 中的这个对象的引用交给 s1 持有。\n\n> **简单理解**：\n对于这句代码，可分为两个过程：\njvm 首先在字符串常量池内里面看看找不找到字符串\"xyz\"；找到，进入第二步；否则，创建新的 String 对象，并“放到”字符串常量池里面。\n然后由于遇到了 new，还会在堆创建 String 对象，其实是拷贝的常量池的那个，拷贝比创建大概快吧...最后将其返回给 s1。\n将 new String(\"xyz\") 拆分为 new String() 和 \"xyz\"\n如果写在类方法里，请参考前面的类加载，就是相比之下提前驻留了吧。\n4. 下面哪段程序能够正确的实现了GBK编码字节流到UTF-8编码字节流的转换： \nbyte[] src,dst;\n> 答案：\ndst=new String (src,”GBK”).getbytes(“UTF-8”)\n\n5. 在使用super和this关键字时，以下描述正确的是（）\n> 答案\n在子类构造方法中使用super（）显示调用父类的构造方法，super（）必须写在子类构造方法的第一行，否则编译不通过\n\n> 解析\n使用super()或者this()方法是必须放在构造函数的第一行\n由于this(%)代表的构造函数默认有super()方法，所以规定this()和super()不能同时出现在一个构造函数中。\n因为static方法或者语句块没有实例时可以使用，而此时不需要构造实例，所以不能用this()和super().\n\n6. 关于 访问权限说法正确 的是 ？ ()\n> 答案:\n内部类前面可以修饰public,protected和private\n\n> 解析\n对于外部类来说，只有两种修饰，public和默认（default），因为外部类放在包中，只有两种可能，包可见和包不可见。\n对于内部类来说，可以有所有的修饰，因为内部类放在外部类中，与成员变量的地位一致，所以有四种可能。\n\n7. 以下代码的输出结果是？\n```java\npublic class B\n{\n    public static B t1 = new B();\n    public static B t2 = new B();\n    {\n        System.out.println(\"构造块\");\n    }\n    static\n    {\n        System.out.println(\"静态块\");\n    }\n    public static void main(String[] args)\n    {\n        B t = new B();\n    }\n}\n```\n> 答案：\n构造块 构造块 静态块 构造块\n\n> 解析：\n并不是静态块最先初始化,而是静态域.\n而静态域中包含静态变量、静态块和静态方法,其中需要初始化的是静态变量和静态块.而他们两个的初始化顺序是靠他们俩的位置决定的!\n\n8.class A {}\nclass B extends A {}\nclass C extends A {}\nclass D extends B {}\nWhich four statements are true ?\n\n> 答案：\n\nThe type List<A> is assignable to List.\nThe type List<Object> is assignable to List\\<?\\>.\nThe type List<D> is assignable to List<?extends B>.\nThe type List<?extends B> is assignable to List<?extends A>.\n\n> 解析\n```\n1. 只看尖括号里边的！！明确点和范围两个概念\n2. 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List\\<A\\>,List<B>,List<Object>\n3. 如果尖括号里面带有问号，那么代表一个范围，<? extends A> 代表小于等于A的范围，<? super A>代表大于等于A的范围，<?>代表全部范围\n4. 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点\n5. 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值\n6. List<?>和List 是相等的，都代表最大范围\n7.List既是点也是范围，当表示范围时，表示最大范围\n```\n9. 在开发中使用泛型取代非泛型的数据类型（比如用ArrayList<String>取代ArrayList），程序的运行时性能会变得更好。（）\n \n> 解析\n泛型仅仅是java的语法糖，它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的.\n\n---\n# 零碎知识\n1. 接口中的变量默认是public static final 的，方法默认是public abstract 的。\n2. 2. 在hashmap中，key值是不可能重复的，由hashCode和equals方法共同判断key值是否相等。即使两个对象的hashCode相同相等，也不能说他们的key值相等。\n3. // 数据类型[][] 数组名;\nint [][] table = new int[2][2];\nint [][] table = new int[2][];\nint [] table [] = new int[2][2];\nint [] table [] = new int[2][];\n都是正确的 new int[2][];若未确定每行的长度 打印出来为空。\n4. \n![image.png](http://uploadfiles.nowcoder.com/images/20151010/214250_1444467985224_6A144C1382BBEF1BE30E9B91BC2973C8)\n> 1. 粉红色的是受检查的异常(checked exceptions),其必须被 try{}catch语句块所捕获,或者在方法签名里通过throws子句声明.受检查的异常必须在编译时被捕捉处理,命名为 Checked Exception 是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守.\n> 2. 绿色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如 空指针,被0除...\n> 3. 而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。\n\n5. final只是指向不变，但是指向的值有可能变，所以依然不是线程安全\n6. 局部变量是指类&成员方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值。\n7. java三大注解\n\n**Override 注解**\n指明被注解的方法需要覆写超类中的方法.\n如果某个方法使用了该注解,却没有覆写超类中的方法(比如大小写写错了,或者参数错了,或者是子类自己定义的方法),编译器就会生成一个错误.\n\n**Deprecated 注解**\n可以修饰类、方法、变量，在java源码中被@Deprecated修饰的类、方法、变量等表示不建议使用的，可能会出现错误的，可能以后会被删除的类、方法等，如果现在使用，则在以后使用了这些类、方法的程序在更新新的JDK、jar包等就会出错，不再提供支持。     个人程序中的类、方法、变量用@Deprecated修饰同样是不希望自己和别人在以后的时间再次使用此类、方法。  当编译器编译时遇到了使用@Deprecated修饰的类、方法、变量时会提示相应的警告信息。\n\n**Suppresswarnings 注解**\n可以达到抑制编译器编译时产生警告的目的，但是很不建议使用@SuppressWarnings注解，使用此注解，编码人员看不到编译时编译器提示的相应的警告，不能选择更好、更新的类、方法或者不能编写更规范的编码。同时后期更新JDK、jar包等源码时，使用@SuppressWarnings注解的代码可能受新的JDK、jar包代码的支持，出现错误，仍然需要修改。\n\n8. 两同两小一大原则\n方法名相同，参数类型相同\n子类返回类型小于等于父类方法返回类型， \n子类抛出异常小于等于父类方法抛出异常， \n子类访问权限大于等于父类方法访问权限。","toc":true,"date":"2019-01-22T13:49:57.000Z","_content":"\n# 错题\n1. 关于以下application,说法正确是什么？\n\n```java\npublic class Test {\n    static int x=10;\n    static {x+=5;}\n    public static void main(String[] args) //4\n        {\n        System.out.println(\"x=\"+x);\n    }\n    static{x/=3;};\n}//9\n```\n\n> 答案：编译通过，执行结果是：x=5\n<!-- more -->\n解析：\n```java\nclass A{\n    static {\n        System.out.println(\"父类静态代码块\");\n    }\n    public A(){\n        System.out.println(\"父类构造方法\");\n    }\n    {\n        System.out.println(\"父类初始化块\");\n    }\n}\npublic class B extends A{\n    static{\n        System.out.println(\"子类静态代码块\");\n    }\n    public B(){\n        System.out.println(\"子类构造方法\");\n    }\n    {\n        System.out.println(\"子类初始化块\");\n    }\n    public static void main(String[] args){\n        new B();\n    }\n}\n```\n父类静态代码块-->子类静态代码块-->父类普通代码块-->父类构造方法-->子类代码块-->子类构造方法；\n<!-- more -->\n2.下面代码的输出是什么？\n```java\npublic class Base\n{\n    private String baseName = \"base\";\n    public Base()\n    {\n        callName();\n    }\n \n    public void callName()\n    {\n        System. out. println(baseName);\n    }\n \n    static class Sub extends Base\n    {\n        private String baseName = \"sub\";\n        public void callName()\n        {\n            System. out. println (baseName) ;\n        }\n    }\n    public static void main(String[] args)\n    {\n        Base b = new Sub();\n    }\n} \n```\n答案\n> null\n\n解析：\n>new Sub();在创造派生类的过程中首先创建基类对象，然后才能创建派生类。\n创建基类即默认调用Base()方法，在方法中调用callName()方法，由于派生类中存在此方法，则被调用的callName（）方法是派生类中的方法，此时派生类还未构造，所以变量baseName的值为null.\n\n3. Java语言中，如果\"xyz\"没有被创建过，String s = new String(“xyz”);创建了几个string对象？\n\n> 答案：2个\n\n> 解析:\n**相关知识点**：\n类加载对一个类只会进行一次。\n\"xyz\" 在类加载时就已经创建并驻留了（如果该类被加载之前已经有 \"xyz\" 字符串被驻留过则不需要重复创建用于驻留的\"xyz\"实例>）。\n\n> 驻留的字符串是放在全局共享的字符串常量池中的。\n\n> 在 HotSpot VM 里实现的 string pool 功能的是一个 StringTable 类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身）\n也就是说在堆中的某些字符串实例被这个 StringTable 引用之后就等同被赋予了”驻留字符串”的身份。\n这个 StringTable 在每个 HotSpot VM 的实例只有一份，被所有的类共享。\n\n> 在这段代码后续被运行的时候，\"xyz\" 字面量对应的 String 实例已经固定了(前面的类加载过程)，不会再被重复创建。\n\n> 所以这段代码将常量池中的对象复制一份放到 heap 中，并且把 heap 中的这个对象的引用交给 s1 持有。\n\n> **简单理解**：\n对于这句代码，可分为两个过程：\njvm 首先在字符串常量池内里面看看找不找到字符串\"xyz\"；找到，进入第二步；否则，创建新的 String 对象，并“放到”字符串常量池里面。\n然后由于遇到了 new，还会在堆创建 String 对象，其实是拷贝的常量池的那个，拷贝比创建大概快吧...最后将其返回给 s1。\n将 new String(\"xyz\") 拆分为 new String() 和 \"xyz\"\n如果写在类方法里，请参考前面的类加载，就是相比之下提前驻留了吧。\n4. 下面哪段程序能够正确的实现了GBK编码字节流到UTF-8编码字节流的转换： \nbyte[] src,dst;\n> 答案：\ndst=new String (src,”GBK”).getbytes(“UTF-8”)\n\n5. 在使用super和this关键字时，以下描述正确的是（）\n> 答案\n在子类构造方法中使用super（）显示调用父类的构造方法，super（）必须写在子类构造方法的第一行，否则编译不通过\n\n> 解析\n使用super()或者this()方法是必须放在构造函数的第一行\n由于this(%)代表的构造函数默认有super()方法，所以规定this()和super()不能同时出现在一个构造函数中。\n因为static方法或者语句块没有实例时可以使用，而此时不需要构造实例，所以不能用this()和super().\n\n6. 关于 访问权限说法正确 的是 ？ ()\n> 答案:\n内部类前面可以修饰public,protected和private\n\n> 解析\n对于外部类来说，只有两种修饰，public和默认（default），因为外部类放在包中，只有两种可能，包可见和包不可见。\n对于内部类来说，可以有所有的修饰，因为内部类放在外部类中，与成员变量的地位一致，所以有四种可能。\n\n7. 以下代码的输出结果是？\n```java\npublic class B\n{\n    public static B t1 = new B();\n    public static B t2 = new B();\n    {\n        System.out.println(\"构造块\");\n    }\n    static\n    {\n        System.out.println(\"静态块\");\n    }\n    public static void main(String[] args)\n    {\n        B t = new B();\n    }\n}\n```\n> 答案：\n构造块 构造块 静态块 构造块\n\n> 解析：\n并不是静态块最先初始化,而是静态域.\n而静态域中包含静态变量、静态块和静态方法,其中需要初始化的是静态变量和静态块.而他们两个的初始化顺序是靠他们俩的位置决定的!\n\n8.class A {}\nclass B extends A {}\nclass C extends A {}\nclass D extends B {}\nWhich four statements are true ?\n\n> 答案：\n\nThe type List<A> is assignable to List.\nThe type List<Object> is assignable to List\\<?\\>.\nThe type List<D> is assignable to List<?extends B>.\nThe type List<?extends B> is assignable to List<?extends A>.\n\n> 解析\n```\n1. 只看尖括号里边的！！明确点和范围两个概念\n2. 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List\\<A\\>,List<B>,List<Object>\n3. 如果尖括号里面带有问号，那么代表一个范围，<? extends A> 代表小于等于A的范围，<? super A>代表大于等于A的范围，<?>代表全部范围\n4. 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点\n5. 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值\n6. List<?>和List 是相等的，都代表最大范围\n7.List既是点也是范围，当表示范围时，表示最大范围\n```\n9. 在开发中使用泛型取代非泛型的数据类型（比如用ArrayList<String>取代ArrayList），程序的运行时性能会变得更好。（）\n \n> 解析\n泛型仅仅是java的语法糖，它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的.\n\n---\n# 零碎知识\n1. 接口中的变量默认是public static final 的，方法默认是public abstract 的。\n2. 2. 在hashmap中，key值是不可能重复的，由hashCode和equals方法共同判断key值是否相等。即使两个对象的hashCode相同相等，也不能说他们的key值相等。\n3. // 数据类型[][] 数组名;\nint [][] table = new int[2][2];\nint [][] table = new int[2][];\nint [] table [] = new int[2][2];\nint [] table [] = new int[2][];\n都是正确的 new int[2][];若未确定每行的长度 打印出来为空。\n4. \n![image.png](http://uploadfiles.nowcoder.com/images/20151010/214250_1444467985224_6A144C1382BBEF1BE30E9B91BC2973C8)\n> 1. 粉红色的是受检查的异常(checked exceptions),其必须被 try{}catch语句块所捕获,或者在方法签名里通过throws子句声明.受检查的异常必须在编译时被捕捉处理,命名为 Checked Exception 是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守.\n> 2. 绿色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如 空指针,被0除...\n> 3. 而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。\n\n5. final只是指向不变，但是指向的值有可能变，所以依然不是线程安全\n6. 局部变量是指类&成员方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值。\n7. java三大注解\n\n**Override 注解**\n指明被注解的方法需要覆写超类中的方法.\n如果某个方法使用了该注解,却没有覆写超类中的方法(比如大小写写错了,或者参数错了,或者是子类自己定义的方法),编译器就会生成一个错误.\n\n**Deprecated 注解**\n可以修饰类、方法、变量，在java源码中被@Deprecated修饰的类、方法、变量等表示不建议使用的，可能会出现错误的，可能以后会被删除的类、方法等，如果现在使用，则在以后使用了这些类、方法的程序在更新新的JDK、jar包等就会出错，不再提供支持。     个人程序中的类、方法、变量用@Deprecated修饰同样是不希望自己和别人在以后的时间再次使用此类、方法。  当编译器编译时遇到了使用@Deprecated修饰的类、方法、变量时会提示相应的警告信息。\n\n**Suppresswarnings 注解**\n可以达到抑制编译器编译时产生警告的目的，但是很不建议使用@SuppressWarnings注解，使用此注解，编码人员看不到编译时编译器提示的相应的警告，不能选择更好、更新的类、方法或者不能编写更规范的编码。同时后期更新JDK、jar包等源码时，使用@SuppressWarnings注解的代码可能受新的JDK、jar包代码的支持，出现错误，仍然需要修改。\n\n8. 两同两小一大原则\n方法名相同，参数类型相同\n子类返回类型小于等于父类方法返回类型， \n子类抛出异常小于等于父类方法抛出异常， \n子类访问权限大于等于父类方法访问权限。","source":"_posts/Java刷题错题以及收集的Java零碎知识。.md","raw":"---\ntitle: Java刷题错题以及收集的Java零碎知识。\ntags:\n  - 语言\n  - 基础\n  - Java\n  - 笔记\noriginContent: >-\n  # 错题\n\n  1. 关于以下application,说法正确是什么？\n\n\n  ```java\n\n  public class Test {\n      static int x=10;\n      static {x+=5;}\n      public static void main(String[] args) //4\n          {\n          System.out.println(\"x=\"+x);\n      }\n      static{x/=3;};\n  }//9\n\n  ```\n\n\n  > 答案：编译通过，执行结果是：x=5\n\n\n  解析：\n\n  ```java\n\n  class A{\n      static {\n          System.out.println(\"父类静态代码块\");\n      }\n      public A(){\n          System.out.println(\"父类构造方法\");\n      }\n      {\n          System.out.println(\"父类初始化块\");\n      }\n  }\n\n  public class B extends A{\n      static{\n          System.out.println(\"子类静态代码块\");\n      }\n      public B(){\n          System.out.println(\"子类构造方法\");\n      }\n      {\n          System.out.println(\"子类初始化块\");\n      }\n      public static void main(String[] args){\n          new B();\n      }\n  }\n\n  ```\n\n  父类静态代码块-->子类静态代码块-->父类普通代码块-->父类构造方法-->子类代码块-->子类构造方法；\n\n  <!-- more -->\n\n  2.下面代码的输出是什么？\n\n  ```java\n\n  public class Base\n\n  {\n      private String baseName = \"base\";\n      public Base()\n      {\n          callName();\n      }\n   \n      public void callName()\n      {\n          System. out. println(baseName);\n      }\n   \n      static class Sub extends Base\n      {\n          private String baseName = \"sub\";\n          public void callName()\n          {\n              System. out. println (baseName) ;\n          }\n      }\n      public static void main(String[] args)\n      {\n          Base b = new Sub();\n      }\n  } \n\n  ```\n\n  答案\n\n  > null\n\n\n  解析：\n\n  >new Sub();在创造派生类的过程中首先创建基类对象，然后才能创建派生类。\n\n  创建基类即默认调用Base()方法，在方法中调用callName()方法，由于派生类中存在此方法，则被调用的callName（）方法是派生类中的方法，此时派生类还未构造，所以变量baseName的值为null.\n\n\n  3. Java语言中，如果\"xyz\"没有被创建过，String s = new String(“xyz”);创建了几个string对象？\n\n\n  > 答案：2个\n\n\n  > 解析:\n\n  **相关知识点**：\n\n  类加载对一个类只会进行一次。\n\n  \"xyz\" 在类加载时就已经创建并驻留了（如果该类被加载之前已经有 \"xyz\" 字符串被驻留过则不需要重复创建用于驻留的\"xyz\"实例>）。\n\n\n  > 驻留的字符串是放在全局共享的字符串常量池中的。\n\n\n  > 在 HotSpot VM 里实现的 string pool 功能的是一个 StringTable\n  类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身）\n\n  也就是说在堆中的某些字符串实例被这个 StringTable 引用之后就等同被赋予了”驻留字符串”的身份。\n\n  这个 StringTable 在每个 HotSpot VM 的实例只有一份，被所有的类共享。\n\n\n  > 在这段代码后续被运行的时候，\"xyz\" 字面量对应的 String 实例已经固定了(前面的类加载过程)，不会再被重复创建。\n\n\n  > 所以这段代码将常量池中的对象复制一份放到 heap 中，并且把 heap 中的这个对象的引用交给 s1 持有。\n\n\n  > **简单理解**：\n\n  对于这句代码，可分为两个过程：\n\n  jvm 首先在字符串常量池内里面看看找不找到字符串\"xyz\"；找到，进入第二步；否则，创建新的 String 对象，并“放到”字符串常量池里面。\n\n  然后由于遇到了 new，还会在堆创建 String 对象，其实是拷贝的常量池的那个，拷贝比创建大概快吧...最后将其返回给 s1。\n\n  将 new String(\"xyz\") 拆分为 new String() 和 \"xyz\"\n\n  如果写在类方法里，请参考前面的类加载，就是相比之下提前驻留了吧。\n\n  4. 下面哪段程序能够正确的实现了GBK编码字节流到UTF-8编码字节流的转换： \n\n  byte[] src,dst;\n\n  > 答案：\n\n  dst=new String (src,”GBK”).getbytes(“UTF-8”)\n\n\n  5. 在使用super和this关键字时，以下描述正确的是（）\n\n  > 答案\n\n  在子类构造方法中使用super（）显示调用父类的构造方法，super（）必须写在子类构造方法的第一行，否则编译不通过\n\n\n  > 解析\n\n  使用super()或者this()方法是必须放在构造函数的第一行\n\n  由于this(%)代表的构造函数默认有super()方法，所以规定this()和super()不能同时出现在一个构造函数中。\n\n  因为static方法或者语句块没有实例时可以使用，而此时不需要构造实例，所以不能用this()和super().\n\n\n  6. 关于 访问权限说法正确 的是 ？ ()\n\n  > 答案:\n\n  内部类前面可以修饰public,protected和private\n\n\n  > 解析\n\n  对于外部类来说，只有两种修饰，public和默认（default），因为外部类放在包中，只有两种可能，包可见和包不可见。\n\n  对于内部类来说，可以有所有的修饰，因为内部类放在外部类中，与成员变量的地位一致，所以有四种可能。\n\n\n  7. 以下代码的输出结果是？\n\n  ```java\n\n  public class B\n\n  {\n      public static B t1 = new B();\n      public static B t2 = new B();\n      {\n          System.out.println(\"构造块\");\n      }\n      static\n      {\n          System.out.println(\"静态块\");\n      }\n      public static void main(String[] args)\n      {\n          B t = new B();\n      }\n  }\n\n  ```\n\n  > 答案：\n\n  构造块 构造块 静态块 构造块\n\n\n  > 解析：\n\n  并不是静态块最先初始化,而是静态域.\n\n  而静态域中包含静态变量、静态块和静态方法,其中需要初始化的是静态变量和静态块.而他们两个的初始化顺序是靠他们俩的位置决定的!\n\n\n  8.class A {}\n\n  class B extends A {}\n\n  class C extends A {}\n\n  class D extends B {}\n\n  Which four statements are true ?\n\n\n  > 答案：\n\n\n  The type List<A> is assignable to List.\n\n  The type List<Object> is assignable to List\\<?\\>.\n\n  The type List<D> is assignable to List<?extends B>.\n\n  The type List<?extends B> is assignable to List<?extends A>.\n\n\n  > 解析\n\n  ```\n\n  1. 只看尖括号里边的！！明确点和范围两个概念\n\n  2. 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List\\<A\\>,List<B>,List<Object>\n\n  3. 如果尖括号里面带有问号，那么代表一个范围，<? extends A> 代表小于等于A的范围，<? super\n  A>代表大于等于A的范围，<?>代表全部范围\n\n  4. 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点\n\n  5. 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值\n\n  6. List<?>和List 是相等的，都代表最大范围\n\n  7.List既是点也是范围，当表示范围时，表示最大范围\n\n  ```\n\n  9. 在开发中使用泛型取代非泛型的数据类型（比如用ArrayList<String>取代ArrayList），程序的运行时性能会变得更好。（）\n   \n  > 解析\n\n  泛型仅仅是java的语法糖，它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的.\n\n\n  ---\n\n  # 零碎知识\n\n  1. 接口中的变量默认是public static final 的，方法默认是public abstract 的。\n\n  2. 2.\n  在hashmap中，key值是不可能重复的，由hashCode和equals方法共同判断key值是否相等。即使两个对象的hashCode相同相等，也不能说他们的key值相等。\n\n  3. // 数据类型[][] 数组名;\n\n  int [][] table = new int[2][2];\n\n  int [][] table = new int[2][];\n\n  int [] table [] = new int[2][2];\n\n  int [] table [] = new int[2][];\n\n  都是正确的 new int[2][];若未确定每行的长度 打印出来为空。\n\n  4. \n\n  ![image.png](http://uploadfiles.nowcoder.com/images/20151010/214250_1444467985224_6A144C1382BBEF1BE30E9B91BC2973C8)\n\n  > 1. 粉红色的是受检查的异常(checked exceptions),其必须被\n  try{}catch语句块所捕获,或者在方法签名里通过throws子句声明.受检查的异常必须在编译时被捕捉处理,命名为 Checked Exception\n  是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守.\n\n  > 2. 绿色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如 空指针,被0除...\n\n  > 3.\n  而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。\n\n\n  5. final只是指向不变，但是指向的值有可能变，所以依然不是线程安全\n\n  6.\n  局部变量是指类&成员方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值。\n\n  7. java三大注解\n\n\n  **Override 注解**\n\n  指明被注解的方法需要覆写超类中的方法.\n\n  如果某个方法使用了该注解,却没有覆写超类中的方法(比如大小写写错了,或者参数错了,或者是子类自己定义的方法),编译器就会生成一个错误.\n\n\n  **Deprecated 注解**\n\n  可以修饰类、方法、变量，在java源码中被@Deprecated修饰的类、方法、变量等表示不建议使用的，可能会出现错误的，可能以后会被删除的类、方法等，如果现在使用，则在以后使用了这些类、方法的程序在更新新的JDK、jar包等就会出错，不再提供支持。    \n  个人程序中的类、方法、变量用@Deprecated修饰同样是不希望自己和别人在以后的时间再次使用此类、方法。 \n  当编译器编译时遇到了使用@Deprecated修饰的类、方法、变量时会提示相应的警告信息。\n\n\n  **Suppresswarnings 注解**\n\n  可以达到抑制编译器编译时产生警告的目的，但是很不建议使用@SuppressWarnings注解，使用此注解，编码人员看不到编译时编译器提示的相应的警告，不能选择更好、更新的类、方法或者不能编写更规范的编码。同时后期更新JDK、jar包等源码时，使用@SuppressWarnings注解的代码可能受新的JDK、jar包代码的支持，出现错误，仍然需要修改。\n\n\n  8. 两同两小一大原则\n\n  方法名相同，参数类型相同\n\n  子类返回类型小于等于父类方法返回类型， \n\n  子类抛出异常小于等于父类方法抛出异常， \n\n  子类访问权限大于等于父类方法访问权限。\ncategories:\n  - Java\ntoc: true\ndate: 2019-01-22 21:49:57\n---\n\n# 错题\n1. 关于以下application,说法正确是什么？\n\n```java\npublic class Test {\n    static int x=10;\n    static {x+=5;}\n    public static void main(String[] args) //4\n        {\n        System.out.println(\"x=\"+x);\n    }\n    static{x/=3;};\n}//9\n```\n\n> 答案：编译通过，执行结果是：x=5\n<!-- more -->\n解析：\n```java\nclass A{\n    static {\n        System.out.println(\"父类静态代码块\");\n    }\n    public A(){\n        System.out.println(\"父类构造方法\");\n    }\n    {\n        System.out.println(\"父类初始化块\");\n    }\n}\npublic class B extends A{\n    static{\n        System.out.println(\"子类静态代码块\");\n    }\n    public B(){\n        System.out.println(\"子类构造方法\");\n    }\n    {\n        System.out.println(\"子类初始化块\");\n    }\n    public static void main(String[] args){\n        new B();\n    }\n}\n```\n父类静态代码块-->子类静态代码块-->父类普通代码块-->父类构造方法-->子类代码块-->子类构造方法；\n<!-- more -->\n2.下面代码的输出是什么？\n```java\npublic class Base\n{\n    private String baseName = \"base\";\n    public Base()\n    {\n        callName();\n    }\n \n    public void callName()\n    {\n        System. out. println(baseName);\n    }\n \n    static class Sub extends Base\n    {\n        private String baseName = \"sub\";\n        public void callName()\n        {\n            System. out. println (baseName) ;\n        }\n    }\n    public static void main(String[] args)\n    {\n        Base b = new Sub();\n    }\n} \n```\n答案\n> null\n\n解析：\n>new Sub();在创造派生类的过程中首先创建基类对象，然后才能创建派生类。\n创建基类即默认调用Base()方法，在方法中调用callName()方法，由于派生类中存在此方法，则被调用的callName（）方法是派生类中的方法，此时派生类还未构造，所以变量baseName的值为null.\n\n3. Java语言中，如果\"xyz\"没有被创建过，String s = new String(“xyz”);创建了几个string对象？\n\n> 答案：2个\n\n> 解析:\n**相关知识点**：\n类加载对一个类只会进行一次。\n\"xyz\" 在类加载时就已经创建并驻留了（如果该类被加载之前已经有 \"xyz\" 字符串被驻留过则不需要重复创建用于驻留的\"xyz\"实例>）。\n\n> 驻留的字符串是放在全局共享的字符串常量池中的。\n\n> 在 HotSpot VM 里实现的 string pool 功能的是一个 StringTable 类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身）\n也就是说在堆中的某些字符串实例被这个 StringTable 引用之后就等同被赋予了”驻留字符串”的身份。\n这个 StringTable 在每个 HotSpot VM 的实例只有一份，被所有的类共享。\n\n> 在这段代码后续被运行的时候，\"xyz\" 字面量对应的 String 实例已经固定了(前面的类加载过程)，不会再被重复创建。\n\n> 所以这段代码将常量池中的对象复制一份放到 heap 中，并且把 heap 中的这个对象的引用交给 s1 持有。\n\n> **简单理解**：\n对于这句代码，可分为两个过程：\njvm 首先在字符串常量池内里面看看找不找到字符串\"xyz\"；找到，进入第二步；否则，创建新的 String 对象，并“放到”字符串常量池里面。\n然后由于遇到了 new，还会在堆创建 String 对象，其实是拷贝的常量池的那个，拷贝比创建大概快吧...最后将其返回给 s1。\n将 new String(\"xyz\") 拆分为 new String() 和 \"xyz\"\n如果写在类方法里，请参考前面的类加载，就是相比之下提前驻留了吧。\n4. 下面哪段程序能够正确的实现了GBK编码字节流到UTF-8编码字节流的转换： \nbyte[] src,dst;\n> 答案：\ndst=new String (src,”GBK”).getbytes(“UTF-8”)\n\n5. 在使用super和this关键字时，以下描述正确的是（）\n> 答案\n在子类构造方法中使用super（）显示调用父类的构造方法，super（）必须写在子类构造方法的第一行，否则编译不通过\n\n> 解析\n使用super()或者this()方法是必须放在构造函数的第一行\n由于this(%)代表的构造函数默认有super()方法，所以规定this()和super()不能同时出现在一个构造函数中。\n因为static方法或者语句块没有实例时可以使用，而此时不需要构造实例，所以不能用this()和super().\n\n6. 关于 访问权限说法正确 的是 ？ ()\n> 答案:\n内部类前面可以修饰public,protected和private\n\n> 解析\n对于外部类来说，只有两种修饰，public和默认（default），因为外部类放在包中，只有两种可能，包可见和包不可见。\n对于内部类来说，可以有所有的修饰，因为内部类放在外部类中，与成员变量的地位一致，所以有四种可能。\n\n7. 以下代码的输出结果是？\n```java\npublic class B\n{\n    public static B t1 = new B();\n    public static B t2 = new B();\n    {\n        System.out.println(\"构造块\");\n    }\n    static\n    {\n        System.out.println(\"静态块\");\n    }\n    public static void main(String[] args)\n    {\n        B t = new B();\n    }\n}\n```\n> 答案：\n构造块 构造块 静态块 构造块\n\n> 解析：\n并不是静态块最先初始化,而是静态域.\n而静态域中包含静态变量、静态块和静态方法,其中需要初始化的是静态变量和静态块.而他们两个的初始化顺序是靠他们俩的位置决定的!\n\n8.class A {}\nclass B extends A {}\nclass C extends A {}\nclass D extends B {}\nWhich four statements are true ?\n\n> 答案：\n\nThe type List<A> is assignable to List.\nThe type List<Object> is assignable to List\\<?\\>.\nThe type List<D> is assignable to List<?extends B>.\nThe type List<?extends B> is assignable to List<?extends A>.\n\n> 解析\n```\n1. 只看尖括号里边的！！明确点和范围两个概念\n2. 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List\\<A\\>,List<B>,List<Object>\n3. 如果尖括号里面带有问号，那么代表一个范围，<? extends A> 代表小于等于A的范围，<? super A>代表大于等于A的范围，<?>代表全部范围\n4. 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点\n5. 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值\n6. List<?>和List 是相等的，都代表最大范围\n7.List既是点也是范围，当表示范围时，表示最大范围\n```\n9. 在开发中使用泛型取代非泛型的数据类型（比如用ArrayList<String>取代ArrayList），程序的运行时性能会变得更好。（）\n \n> 解析\n泛型仅仅是java的语法糖，它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的.\n\n---\n# 零碎知识\n1. 接口中的变量默认是public static final 的，方法默认是public abstract 的。\n2. 2. 在hashmap中，key值是不可能重复的，由hashCode和equals方法共同判断key值是否相等。即使两个对象的hashCode相同相等，也不能说他们的key值相等。\n3. // 数据类型[][] 数组名;\nint [][] table = new int[2][2];\nint [][] table = new int[2][];\nint [] table [] = new int[2][2];\nint [] table [] = new int[2][];\n都是正确的 new int[2][];若未确定每行的长度 打印出来为空。\n4. \n![image.png](http://uploadfiles.nowcoder.com/images/20151010/214250_1444467985224_6A144C1382BBEF1BE30E9B91BC2973C8)\n> 1. 粉红色的是受检查的异常(checked exceptions),其必须被 try{}catch语句块所捕获,或者在方法签名里通过throws子句声明.受检查的异常必须在编译时被捕捉处理,命名为 Checked Exception 是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守.\n> 2. 绿色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如 空指针,被0除...\n> 3. 而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。\n\n5. final只是指向不变，但是指向的值有可能变，所以依然不是线程安全\n6. 局部变量是指类&成员方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值。\n7. java三大注解\n\n**Override 注解**\n指明被注解的方法需要覆写超类中的方法.\n如果某个方法使用了该注解,却没有覆写超类中的方法(比如大小写写错了,或者参数错了,或者是子类自己定义的方法),编译器就会生成一个错误.\n\n**Deprecated 注解**\n可以修饰类、方法、变量，在java源码中被@Deprecated修饰的类、方法、变量等表示不建议使用的，可能会出现错误的，可能以后会被删除的类、方法等，如果现在使用，则在以后使用了这些类、方法的程序在更新新的JDK、jar包等就会出错，不再提供支持。     个人程序中的类、方法、变量用@Deprecated修饰同样是不希望自己和别人在以后的时间再次使用此类、方法。  当编译器编译时遇到了使用@Deprecated修饰的类、方法、变量时会提示相应的警告信息。\n\n**Suppresswarnings 注解**\n可以达到抑制编译器编译时产生警告的目的，但是很不建议使用@SuppressWarnings注解，使用此注解，编码人员看不到编译时编译器提示的相应的警告，不能选择更好、更新的类、方法或者不能编写更规范的编码。同时后期更新JDK、jar包等源码时，使用@SuppressWarnings注解的代码可能受新的JDK、jar包代码的支持，出现错误，仍然需要修改。\n\n8. 两同两小一大原则\n方法名相同，参数类型相同\n子类返回类型小于等于父类方法返回类型， \n子类抛出异常小于等于父类方法抛出异常， \n子类访问权限大于等于父类方法访问权限。","slug":"Java刷题错题以及收集的Java零碎知识。","published":1,"updated":"2019-03-29T05:54:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22tga3w0004wureciai2046","content":"<h1 id=\"错题\"><a href=\"#错题\" class=\"headerlink\" title=\"错题\"></a>错题</h1><ol>\n<li>关于以下application,说法正确是什么？</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> x=<span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;x+=<span class=\"number\">5</span>;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"comment\">//4</span></span></span><br><span class=\"line\"><span class=\"function\">        </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"x=\"</span>+x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span>&#123;x/=<span class=\"number\">3</span>;&#125;;</span><br><span class=\"line\">&#125;<span class=\"comment\">//9</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>答案：编译通过，执行结果是：x=5<br><a id=\"more\"></a><br>解析：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"父类静态代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">A</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"父类构造方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"父类初始化块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"子类静态代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">B</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"子类构造方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"子类初始化块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>父类静态代码块–&gt;子类静态代码块–&gt;父类普通代码块–&gt;父类构造方法–&gt;子类代码块–&gt;子类构造方法；<br><!-- more --><br>2.下面代码的输出是什么？<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String baseName = <span class=\"string\">\"base\"</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Base</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        callName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callName</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System. out. println(baseName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String baseName = <span class=\"string\">\"sub\"</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callName</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">        </span>&#123;</span><br><span class=\"line\">            System. out. println (baseName) ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Base b = <span class=\"keyword\">new</span> Sub();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>答案</p>\n<blockquote>\n<p>null</p>\n</blockquote>\n<p>解析：</p>\n<blockquote>\n<p>new Sub();在创造派生类的过程中首先创建基类对象，然后才能创建派生类。<br>创建基类即默认调用Base()方法，在方法中调用callName()方法，由于派生类中存在此方法，则被调用的callName（）方法是派生类中的方法，此时派生类还未构造，所以变量baseName的值为null.</p>\n</blockquote>\n<ol start=\"3\">\n<li>Java语言中，如果”xyz”没有被创建过，String s = new String(“xyz”);创建了几个string对象？</li>\n</ol>\n<blockquote>\n<p>答案：2个</p>\n</blockquote>\n<blockquote>\n<p>解析:<br><strong>相关知识点</strong>：<br>类加载对一个类只会进行一次。<br>“xyz” 在类加载时就已经创建并驻留了（如果该类被加载之前已经有 “xyz” 字符串被驻留过则不需要重复创建用于驻留的”xyz”实例&gt;）。</p>\n</blockquote>\n<blockquote>\n<p>驻留的字符串是放在全局共享的字符串常量池中的。</p>\n</blockquote>\n<blockquote>\n<p>在 HotSpot VM 里实现的 string pool 功能的是一个 StringTable 类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身）<br>也就是说在堆中的某些字符串实例被这个 StringTable 引用之后就等同被赋予了”驻留字符串”的身份。<br>这个 StringTable 在每个 HotSpot VM 的实例只有一份，被所有的类共享。</p>\n</blockquote>\n<blockquote>\n<p>在这段代码后续被运行的时候，”xyz” 字面量对应的 String 实例已经固定了(前面的类加载过程)，不会再被重复创建。</p>\n</blockquote>\n<blockquote>\n<p>所以这段代码将常量池中的对象复制一份放到 heap 中，并且把 heap 中的这个对象的引用交给 s1 持有。</p>\n</blockquote>\n<blockquote>\n<p><strong>简单理解</strong>：<br>对于这句代码，可分为两个过程：<br>jvm 首先在字符串常量池内里面看看找不找到字符串”xyz”；找到，进入第二步；否则，创建新的 String 对象，并“放到”字符串常量池里面。<br>然后由于遇到了 new，还会在堆创建 String 对象，其实是拷贝的常量池的那个，拷贝比创建大概快吧…最后将其返回给 s1。<br>将 new String(“xyz”) 拆分为 new String() 和 “xyz”<br>如果写在类方法里，请参考前面的类加载，就是相比之下提前驻留了吧。</p>\n<ol start=\"4\">\n<li>下面哪段程序能够正确的实现了GBK编码字节流到UTF-8编码字节流的转换：<br>byte[] src,dst;<br>答案：<br>dst=new String (src,”GBK”).getbytes(“UTF-8”)</li>\n</ol>\n</blockquote>\n<ol start=\"5\">\n<li>在使用super和this关键字时，以下描述正确的是（）<blockquote>\n<p>答案<br>在子类构造方法中使用super（）显示调用父类的构造方法，super（）必须写在子类构造方法的第一行，否则编译不通过</p>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<p>解析<br>使用super()或者this()方法是必须放在构造函数的第一行<br>由于this(%)代表的构造函数默认有super()方法，所以规定this()和super()不能同时出现在一个构造函数中。<br>因为static方法或者语句块没有实例时可以使用，而此时不需要构造实例，所以不能用this()和super().</p>\n</blockquote>\n<ol start=\"6\">\n<li>关于 访问权限说法正确 的是 ？ ()<blockquote>\n<p>答案:<br>内部类前面可以修饰public,protected和private</p>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<p>解析<br>对于外部类来说，只有两种修饰，public和默认（default），因为外部类放在包中，只有两种可能，包可见和包不可见。<br>对于内部类来说，可以有所有的修饰，因为内部类放在外部类中，与成员变量的地位一致，所以有四种可能。</p>\n</blockquote>\n<ol start=\"7\">\n<li>以下代码的输出结果是？<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> B t1 = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> B t2 = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"构造块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"静态块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        B t = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<blockquote>\n<p>答案：<br>构造块 构造块 静态块 构造块</p>\n</blockquote>\n<blockquote>\n<p>解析：<br>并不是静态块最先初始化,而是静态域.<br>而静态域中包含静态变量、静态块和静态方法,其中需要初始化的是静态变量和静态块.而他们两个的初始化顺序是靠他们俩的位置决定的!</p>\n</blockquote>\n<p>8.class A {}<br>class B extends A {}<br>class C extends A {}<br>class D extends B {}<br>Which four statements are true ?</p>\n<blockquote>\n<p>答案：</p>\n</blockquote>\n<p>The type List<a> is assignable to List.<br>The type List<object> is assignable to List\\&lt;?>.<br>The type List<d> is assignable to List&lt;?extends B&gt;.<br>The type List&lt;?extends B&gt; is assignable to List&lt;?extends A&gt;.</d></object></a></p>\n<blockquote>\n<p>解析<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 只看尖括号里边的！！明确点和范围两个概念</span><br><span class=\"line\">2. 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List\\&lt;A\\&gt;,List&lt;B&gt;,List&lt;Object&gt;</span><br><span class=\"line\">3. 如果尖括号里面带有问号，那么代表一个范围，&lt;? extends A&gt; 代表小于等于A的范围，&lt;? super A&gt;代表大于等于A的范围，&lt;?&gt;代表全部范围</span><br><span class=\"line\">4. 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点</span><br><span class=\"line\">5. 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值</span><br><span class=\"line\">6. List&lt;?&gt;和List 是相等的，都代表最大范围</span><br><span class=\"line\">7.List既是点也是范围，当表示范围时，表示最大范围</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<ol start=\"9\">\n<li>在开发中使用泛型取代非泛型的数据类型（比如用ArrayList<string>取代ArrayList），程序的运行时性能会变得更好。（）</string></li>\n</ol>\n<blockquote>\n<p>解析<br>泛型仅仅是java的语法糖，它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的.</p>\n</blockquote>\n<hr>\n<h1 id=\"零碎知识\"><a href=\"#零碎知识\" class=\"headerlink\" title=\"零碎知识\"></a>零碎知识</h1><ol>\n<li>接口中的变量默认是public static final 的，方法默认是public abstract 的。</li>\n<li><ol start=\"2\">\n<li>在hashmap中，key值是不可能重复的，由hashCode和equals方法共同判断key值是否相等。即使两个对象的hashCode相同相等，也不能说他们的key值相等。</li>\n</ol>\n</li>\n<li>// 数据类型[][] 数组名;<br>int [][] table = new int[2][2];<br>int [][] table = new int[2][];<br>int [] table [] = new int[2][2];<br>int [] table [] = new int[2][];<br>都是正确的 new int[2][];若未确定每行的长度 打印出来为空。</li>\n<li><p><img src=\"http://uploadfiles.nowcoder.com/images/20151010/214250_1444467985224_6A144C1382BBEF1BE30E9B91BC2973C8\" alt=\"image.png\"></p>\n<blockquote>\n<ol>\n<li>粉红色的是受检查的异常(checked exceptions),其必须被 try{}catch语句块所捕获,或者在方法签名里通过throws子句声明.受检查的异常必须在编译时被捕捉处理,命名为 Checked Exception 是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守.</li>\n<li>绿色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如 空指针,被0除…</li>\n<li>而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。</li>\n</ol>\n</blockquote>\n</li>\n<li><p>final只是指向不变，但是指向的值有可能变，所以依然不是线程安全</p>\n</li>\n<li>局部变量是指类&amp;成员方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值。</li>\n<li>java三大注解</li>\n</ol>\n<p><strong>Override 注解</strong><br>指明被注解的方法需要覆写超类中的方法.<br>如果某个方法使用了该注解,却没有覆写超类中的方法(比如大小写写错了,或者参数错了,或者是子类自己定义的方法),编译器就会生成一个错误.</p>\n<p><strong>Deprecated 注解</strong><br>可以修饰类、方法、变量，在java源码中被@Deprecated修饰的类、方法、变量等表示不建议使用的，可能会出现错误的，可能以后会被删除的类、方法等，如果现在使用，则在以后使用了这些类、方法的程序在更新新的JDK、jar包等就会出错，不再提供支持。     个人程序中的类、方法、变量用@Deprecated修饰同样是不希望自己和别人在以后的时间再次使用此类、方法。  当编译器编译时遇到了使用@Deprecated修饰的类、方法、变量时会提示相应的警告信息。</p>\n<p><strong>Suppresswarnings 注解</strong><br>可以达到抑制编译器编译时产生警告的目的，但是很不建议使用@SuppressWarnings注解，使用此注解，编码人员看不到编译时编译器提示的相应的警告，不能选择更好、更新的类、方法或者不能编写更规范的编码。同时后期更新JDK、jar包等源码时，使用@SuppressWarnings注解的代码可能受新的JDK、jar包代码的支持，出现错误，仍然需要修改。</p>\n<ol start=\"8\">\n<li>两同两小一大原则<br>方法名相同，参数类型相同<br>子类返回类型小于等于父类方法返回类型，<br>子类抛出异常小于等于父类方法抛出异常，<br>子类访问权限大于等于父类方法访问权限。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"错题\"><a href=\"#错题\" class=\"headerlink\" title=\"错题\"></a>错题</h1><ol>\n<li>关于以下application,说法正确是什么？</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> x=<span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;x+=<span class=\"number\">5</span>;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"comment\">//4</span></span></span><br><span class=\"line\"><span class=\"function\">        </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"x=\"</span>+x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span>&#123;x/=<span class=\"number\">3</span>;&#125;;</span><br><span class=\"line\">&#125;<span class=\"comment\">//9</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>答案：编译通过，执行结果是：x=5<br>","more":"<br>解析：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"父类静态代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">A</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"父类构造方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"父类初始化块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"子类静态代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">B</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"子类构造方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"子类初始化块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>父类静态代码块–&gt;子类静态代码块–&gt;父类普通代码块–&gt;父类构造方法–&gt;子类代码块–&gt;子类构造方法；<br><!-- more --><br>2.下面代码的输出是什么？<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String baseName = <span class=\"string\">\"base\"</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Base</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        callName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callName</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System. out. println(baseName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String baseName = <span class=\"string\">\"sub\"</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callName</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">        </span>&#123;</span><br><span class=\"line\">            System. out. println (baseName) ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Base b = <span class=\"keyword\">new</span> Sub();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>答案</p>\n<blockquote>\n<p>null</p>\n</blockquote>\n<p>解析：</p>\n<blockquote>\n<p>new Sub();在创造派生类的过程中首先创建基类对象，然后才能创建派生类。<br>创建基类即默认调用Base()方法，在方法中调用callName()方法，由于派生类中存在此方法，则被调用的callName（）方法是派生类中的方法，此时派生类还未构造，所以变量baseName的值为null.</p>\n</blockquote>\n<ol start=\"3\">\n<li>Java语言中，如果”xyz”没有被创建过，String s = new String(“xyz”);创建了几个string对象？</li>\n</ol>\n<blockquote>\n<p>答案：2个</p>\n</blockquote>\n<blockquote>\n<p>解析:<br><strong>相关知识点</strong>：<br>类加载对一个类只会进行一次。<br>“xyz” 在类加载时就已经创建并驻留了（如果该类被加载之前已经有 “xyz” 字符串被驻留过则不需要重复创建用于驻留的”xyz”实例&gt;）。</p>\n</blockquote>\n<blockquote>\n<p>驻留的字符串是放在全局共享的字符串常量池中的。</p>\n</blockquote>\n<blockquote>\n<p>在 HotSpot VM 里实现的 string pool 功能的是一个 StringTable 类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身）<br>也就是说在堆中的某些字符串实例被这个 StringTable 引用之后就等同被赋予了”驻留字符串”的身份。<br>这个 StringTable 在每个 HotSpot VM 的实例只有一份，被所有的类共享。</p>\n</blockquote>\n<blockquote>\n<p>在这段代码后续被运行的时候，”xyz” 字面量对应的 String 实例已经固定了(前面的类加载过程)，不会再被重复创建。</p>\n</blockquote>\n<blockquote>\n<p>所以这段代码将常量池中的对象复制一份放到 heap 中，并且把 heap 中的这个对象的引用交给 s1 持有。</p>\n</blockquote>\n<blockquote>\n<p><strong>简单理解</strong>：<br>对于这句代码，可分为两个过程：<br>jvm 首先在字符串常量池内里面看看找不找到字符串”xyz”；找到，进入第二步；否则，创建新的 String 对象，并“放到”字符串常量池里面。<br>然后由于遇到了 new，还会在堆创建 String 对象，其实是拷贝的常量池的那个，拷贝比创建大概快吧…最后将其返回给 s1。<br>将 new String(“xyz”) 拆分为 new String() 和 “xyz”<br>如果写在类方法里，请参考前面的类加载，就是相比之下提前驻留了吧。</p>\n<ol start=\"4\">\n<li>下面哪段程序能够正确的实现了GBK编码字节流到UTF-8编码字节流的转换：<br>byte[] src,dst;<br>答案：<br>dst=new String (src,”GBK”).getbytes(“UTF-8”)</li>\n</ol>\n</blockquote>\n<ol start=\"5\">\n<li>在使用super和this关键字时，以下描述正确的是（）<blockquote>\n<p>答案<br>在子类构造方法中使用super（）显示调用父类的构造方法，super（）必须写在子类构造方法的第一行，否则编译不通过</p>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<p>解析<br>使用super()或者this()方法是必须放在构造函数的第一行<br>由于this(%)代表的构造函数默认有super()方法，所以规定this()和super()不能同时出现在一个构造函数中。<br>因为static方法或者语句块没有实例时可以使用，而此时不需要构造实例，所以不能用this()和super().</p>\n</blockquote>\n<ol start=\"6\">\n<li>关于 访问权限说法正确 的是 ？ ()<blockquote>\n<p>答案:<br>内部类前面可以修饰public,protected和private</p>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<p>解析<br>对于外部类来说，只有两种修饰，public和默认（default），因为外部类放在包中，只有两种可能，包可见和包不可见。<br>对于内部类来说，可以有所有的修饰，因为内部类放在外部类中，与成员变量的地位一致，所以有四种可能。</p>\n</blockquote>\n<ol start=\"7\">\n<li>以下代码的输出结果是？<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> B t1 = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> B t2 = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"构造块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"静态块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        B t = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<blockquote>\n<p>答案：<br>构造块 构造块 静态块 构造块</p>\n</blockquote>\n<blockquote>\n<p>解析：<br>并不是静态块最先初始化,而是静态域.<br>而静态域中包含静态变量、静态块和静态方法,其中需要初始化的是静态变量和静态块.而他们两个的初始化顺序是靠他们俩的位置决定的!</p>\n</blockquote>\n<p>8.class A {}<br>class B extends A {}<br>class C extends A {}<br>class D extends B {}<br>Which four statements are true ?</p>\n<blockquote>\n<p>答案：</p>\n</blockquote>\n<p>The type List<a> is assignable to List.<br>The type List<object> is assignable to List\\&lt;?>.<br>The type List<d> is assignable to List&lt;?extends B&gt;.<br>The type List&lt;?extends B&gt; is assignable to List&lt;?extends A&gt;.</d></object></a></p>\n<blockquote>\n<p>解析<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 只看尖括号里边的！！明确点和范围两个概念</span><br><span class=\"line\">2. 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List\\&lt;A\\&gt;,List&lt;B&gt;,List&lt;Object&gt;</span><br><span class=\"line\">3. 如果尖括号里面带有问号，那么代表一个范围，&lt;? extends A&gt; 代表小于等于A的范围，&lt;? super A&gt;代表大于等于A的范围，&lt;?&gt;代表全部范围</span><br><span class=\"line\">4. 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点</span><br><span class=\"line\">5. 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值</span><br><span class=\"line\">6. List&lt;?&gt;和List 是相等的，都代表最大范围</span><br><span class=\"line\">7.List既是点也是范围，当表示范围时，表示最大范围</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<ol start=\"9\">\n<li>在开发中使用泛型取代非泛型的数据类型（比如用ArrayList<string>取代ArrayList），程序的运行时性能会变得更好。（）</string></li>\n</ol>\n<blockquote>\n<p>解析<br>泛型仅仅是java的语法糖，它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的.</p>\n</blockquote>\n<hr>\n<h1 id=\"零碎知识\"><a href=\"#零碎知识\" class=\"headerlink\" title=\"零碎知识\"></a>零碎知识</h1><ol>\n<li>接口中的变量默认是public static final 的，方法默认是public abstract 的。</li>\n<li><ol start=\"2\">\n<li>在hashmap中，key值是不可能重复的，由hashCode和equals方法共同判断key值是否相等。即使两个对象的hashCode相同相等，也不能说他们的key值相等。</li>\n</ol>\n</li>\n<li>// 数据类型[][] 数组名;<br>int [][] table = new int[2][2];<br>int [][] table = new int[2][];<br>int [] table [] = new int[2][2];<br>int [] table [] = new int[2][];<br>都是正确的 new int[2][];若未确定每行的长度 打印出来为空。</li>\n<li><p><img src=\"http://uploadfiles.nowcoder.com/images/20151010/214250_1444467985224_6A144C1382BBEF1BE30E9B91BC2973C8\" alt=\"image.png\"></p>\n<blockquote>\n<ol>\n<li>粉红色的是受检查的异常(checked exceptions),其必须被 try{}catch语句块所捕获,或者在方法签名里通过throws子句声明.受检查的异常必须在编译时被捕捉处理,命名为 Checked Exception 是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守.</li>\n<li>绿色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如 空指针,被0除…</li>\n<li>而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。</li>\n</ol>\n</blockquote>\n</li>\n<li><p>final只是指向不变，但是指向的值有可能变，所以依然不是线程安全</p>\n</li>\n<li>局部变量是指类&amp;成员方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值。</li>\n<li>java三大注解</li>\n</ol>\n<p><strong>Override 注解</strong><br>指明被注解的方法需要覆写超类中的方法.<br>如果某个方法使用了该注解,却没有覆写超类中的方法(比如大小写写错了,或者参数错了,或者是子类自己定义的方法),编译器就会生成一个错误.</p>\n<p><strong>Deprecated 注解</strong><br>可以修饰类、方法、变量，在java源码中被@Deprecated修饰的类、方法、变量等表示不建议使用的，可能会出现错误的，可能以后会被删除的类、方法等，如果现在使用，则在以后使用了这些类、方法的程序在更新新的JDK、jar包等就会出错，不再提供支持。     个人程序中的类、方法、变量用@Deprecated修饰同样是不希望自己和别人在以后的时间再次使用此类、方法。  当编译器编译时遇到了使用@Deprecated修饰的类、方法、变量时会提示相应的警告信息。</p>\n<p><strong>Suppresswarnings 注解</strong><br>可以达到抑制编译器编译时产生警告的目的，但是很不建议使用@SuppressWarnings注解，使用此注解，编码人员看不到编译时编译器提示的相应的警告，不能选择更好、更新的类、方法或者不能编写更规范的编码。同时后期更新JDK、jar包等源码时，使用@SuppressWarnings注解的代码可能受新的JDK、jar包代码的支持，出现错误，仍然需要修改。</p>\n<ol start=\"8\">\n<li>两同两小一大原则<br>方法名相同，参数类型相同<br>子类返回类型小于等于父类方法返回类型，<br>子类抛出异常小于等于父类方法抛出异常，<br>子类访问权限大于等于父类方法访问权限。</li>\n</ol>"},{"title":"MySql两阶段加锁（2PL）协议剖析","originContent":"（转）MySql两阶段加锁（2PL）协议剖析\n------------------------------\n\n本文主要是讲述MySql(仅限innodb)的两阶段加锁(2PL)协议,而非两阶段提交(2PC)协议。\n**前言**\n\n本文主要是讲述MySql(仅限innodb)的两阶段加锁(2PL)协议,而非两阶段提交(2PC)协议,区别如下:\n\n-   2PL,两阶段加锁协议:主要用于单机事务中的一致性与隔离性。\n-   2PC,两阶段提交协议:主要用于分布式事务。\n\nMySql本身针对性能，还有一个MVCC(多版本控制)控制,本文不考虑此种技术，仅仅考虑MySql本身的加锁协议。\n\n**什么时候会加锁**\n\n在对记录更新操作或者(select for update、lock in share\nmodel)时，会对记录加锁(有共享锁、排它锁、意向锁、gap锁、nextkey锁等等),本文为了简单考虑，不考虑锁的种类。\n\n**什么是两阶段加锁**\n\n在一个事务里面，分为加锁(lock)阶段和解锁(unlock)阶段,也即所有的lock操作都在unlock操作之前,如下图所示:\n\n[![](http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwugKB4awcAAAnfbnAG3o214.jpg-wh_651x-s_174240002.jpg)](http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwugKB4awcAAAnfbnAG3o214.jpg-wh_651x-s_174240002.jpg)\n\n**为什么需要两阶段加锁**\n\n引入2PL是为了保证事务的隔离性，即多个事务在并发的情况下等同于串行的执行。\n在数学上证明了如下的封锁定理:\n\n如果事务是良构的且是两阶段的，那么任何一个合法的调度都是隔离的。\n\n具体的数学推到过程可以参照&lt;&lt;事务处理:概念与技术&gt;&gt;这本书的7.5.8.2节.\n\n此书乃是关于数据库事务的圣经，无需解释(中文翻译虽然晦涩，也能坚持读下去,强烈推荐)\n\n**工程实践中的两阶段加锁-S2PL**\n\n在实际情况下，SQL是千变万化、条数不定的,数据库很难在事务中判定什么是加锁阶段，什么是解锁阶段。于是引入了S2PL(Strict-2PL),即:\n\n在事务中只有提交(commit)或者回滚(rollback)时才是解锁阶段，其余时间为加锁阶段。\n\n如下图所示:\n\n[![](http://s3.51cto.com/wyfs02/M01/9C/79/wKiom1lwuhaRYo6tAAArQrdDeok245.jpg)](http://s3.51cto.com/wyfs02/M01/9C/79/wKiom1lwuhaRYo6tAAArQrdDeok245.jpg)\n\n这样的话，在实际的数据库中就很容易实现了。\n\n**两阶段加锁对性能的影响**\n\n上面很好的解释了两阶段加锁，现在我们分析下其对性能的影响。考虑下面两种不同的扣减库存的方案:\n\n[![](http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwu02RnfVLAAAtrhnPMvM342.jpg)](http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwu02RnfVLAAAtrhnPMvM342.jpg)\n\n[![](http://s5.51cto.com/wyfs02/M02/9C/79/wKioL1lwu1zC-atKAAAt2jSMCi0963.jpg)](http://s5.51cto.com/wyfs02/M02/9C/79/wKioL1lwu1zC-atKAAAt2jSMCi0963.jpg)\n\n由于在同一个事务之内，这几条对数据库的操作应该是等价的。但在两阶段加锁下的性能确是有比较大的差距。两者方案的时序如下图所示:\n\n[![](http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwujKi95pyAABND8qPNds262.jpg)](http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwujKi95pyAABND8qPNds262.jpg)\n\n由于库存往往是最重要的热点，是整个系统的瓶颈。那么如果采用第二种方案的话,tps应该理论上能够提升3rt/rt=3倍。这还仅仅是业务就只有三条SQL的情况下，多一条sql就多一次rt,就多一倍的时间。\n\n值得注意的是：\n\n在更新到数据库的那个时间点才算锁成功，提交到数据库的时候才算解锁成功，这两个round\\_trip的前半段是不会计算在内的。\n\n如下图所示:\n\n[![](http://s5.51cto.com/wyfs02/M01/9C/79/wKioL1lwuj7QYAiwAABPkG0laHY133.jpg)](http://s5.51cto.com/wyfs02/M01/9C/79/wKioL1lwuj7QYAiwAABPkG0laHY133.jpg)\n\n当前只考虑网络时延，不考虑数据库和应用本身的时间消耗。\n\n**依据S2PL的性能优化**\n\n从上面的例子中,可以看出，需要把最热点的记录，放到事务最后，这样可以显著的提高吞吐量。更进一步:越热点记录离事务的终点越近(无论是commit还是rollback)\n\n笔者认为，先后顺序如下图:\n\n[![](http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwuk-R4qkXAAA7SDcppns985.png)](http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwuk-R4qkXAAA7SDcppns985.png)\n\n**避免死锁**\n\n这也是任何SQL加锁不可避免的。上文提到了按照记录Key的热度在事务中倒序排列。\n那么写代码的时候任何可能并发的SQL都必须按照这种顺序来处理，不然会造成死锁。如下图所示:\n\n[![](http://s1.51cto.com/wyfs02/M00/9C/79/wKiom1lwulyTw2NJAAAyulGqG34861.jpg)](http://s1.51cto.com/wyfs02/M00/9C/79/wKiom1lwulyTw2NJAAAyulGqG34861.jpg) \n\n**select for update和update where谓词计算**\n\n我们可以直接将一些简单的判断逻辑写到update的谓词里面，以减少加锁时间，考虑下面两种方案:\n\n方案1:\n\n [![](http://s2.51cto.com/wyfs02/M01/9C/79/wKiom1lwurTxzMLTAAByOdzp-VQ938.png)](http://s2.51cto.com/wyfs02/M01/9C/79/wKiom1lwurTxzMLTAAByOdzp-VQ938.png)\n\n方案2:\n\n[![](http://s2.51cto.com/wyfs02/M02/9C/79/wKiom1lwusOTX4_OAAA0ln26OdE506.png)](http://s2.51cto.com/wyfs02/M02/9C/79/wKiom1lwusOTX4_OAAA0ln26OdE506.png)\n\n如图所示:\n\n[![](http://s1.51cto.com/wyfs02/M00/9C/79/wKioL1lwumrhwj4SAABDZNCHCTk850.jpg)](http://s1.51cto.com/wyfs02/M00/9C/79/wKioL1lwumrhwj4SAABDZNCHCTk850.jpg)\n\n可以看到，通过在update中加谓词计算，少了1rt的时间。\n\n由于update在执行过程中对符合谓词条件的记录加的是和select for\nupdate一致的排它锁(具体的锁类型较为复杂，不在这里描述),所以两者效果一样。\n\n总结\n\nMySql采用两阶段加锁协议实现隔离性和一致性，我们只有深入的去理解这种协议，才能更好的对我们的SQL进行优化，增加系统的吞吐量.","toc":true,"date":"2019-02-27T11:00:40.000Z","_content":"\n（转）MySql两阶段加锁（2PL）协议剖析\n------------------------------\n\n本文主要是讲述MySql(仅限innodb)的两阶段加锁(2PL)协议,而非两阶段提交(2PC)协议。\n**前言**\n\n本文主要是讲述MySql(仅限innodb)的两阶段加锁(2PL)协议,而非两阶段提交(2PC)协议,区别如下:\n\n-   2PL,两阶段加锁协议:主要用于单机事务中的一致性与隔离性。\n-   2PC,两阶段提交协议:主要用于分布式事务。\n\nMySql本身针对性能，还有一个MVCC(多版本控制)控制,本文不考虑此种技术，仅仅考虑MySql本身的加锁协议。\n<!-- more -->\n**什么时候会加锁**\n\n在对记录更新操作或者(select for update、lock in share\nmodel)时，会对记录加锁(有共享锁、排它锁、意向锁、gap锁、nextkey锁等等),本文为了简单考虑，不考虑锁的种类。\n\n**什么是两阶段加锁**\n\n在一个事务里面，分为加锁(lock)阶段和解锁(unlock)阶段,也即所有的lock操作都在unlock操作之前,如下图所示:\n\n[![](http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwugKB4awcAAAnfbnAG3o214.jpg-wh_651x-s_174240002.jpg)](http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwugKB4awcAAAnfbnAG3o214.jpg-wh_651x-s_174240002.jpg)\n\n**为什么需要两阶段加锁**\n\n引入2PL是为了保证事务的隔离性，即多个事务在并发的情况下等同于串行的执行。\n在数学上证明了如下的封锁定理:\n\n如果事务是良构的且是两阶段的，那么任何一个合法的调度都是隔离的。\n\n具体的数学推到过程可以参照&lt;&lt;事务处理:概念与技术&gt;&gt;这本书的7.5.8.2节.\n\n此书乃是关于数据库事务的圣经，无需解释(中文翻译虽然晦涩，也能坚持读下去,强烈推荐)\n\n**工程实践中的两阶段加锁-S2PL**\n\n在实际情况下，SQL是千变万化、条数不定的,数据库很难在事务中判定什么是加锁阶段，什么是解锁阶段。于是引入了S2PL(Strict-2PL),即:\n\n在事务中只有提交(commit)或者回滚(rollback)时才是解锁阶段，其余时间为加锁阶段。\n\n如下图所示:\n\n[![](http://s3.51cto.com/wyfs02/M01/9C/79/wKiom1lwuhaRYo6tAAArQrdDeok245.jpg)](http://s3.51cto.com/wyfs02/M01/9C/79/wKiom1lwuhaRYo6tAAArQrdDeok245.jpg)\n\n这样的话，在实际的数据库中就很容易实现了。\n\n**两阶段加锁对性能的影响**\n\n上面很好的解释了两阶段加锁，现在我们分析下其对性能的影响。考虑下面两种不同的扣减库存的方案:\n\n[![](http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwu02RnfVLAAAtrhnPMvM342.jpg)](http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwu02RnfVLAAAtrhnPMvM342.jpg)\n\n[![](http://s5.51cto.com/wyfs02/M02/9C/79/wKioL1lwu1zC-atKAAAt2jSMCi0963.jpg)](http://s5.51cto.com/wyfs02/M02/9C/79/wKioL1lwu1zC-atKAAAt2jSMCi0963.jpg)\n\n由于在同一个事务之内，这几条对数据库的操作应该是等价的。但在两阶段加锁下的性能确是有比较大的差距。两者方案的时序如下图所示:\n\n[![](http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwujKi95pyAABND8qPNds262.jpg)](http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwujKi95pyAABND8qPNds262.jpg)\n\n由于库存往往是最重要的热点，是整个系统的瓶颈。那么如果采用第二种方案的话,tps应该理论上能够提升3rt/rt=3倍。这还仅仅是业务就只有三条SQL的情况下，多一条sql就多一次rt,就多一倍的时间。\n\n值得注意的是：\n\n在更新到数据库的那个时间点才算锁成功，提交到数据库的时候才算解锁成功，这两个round\\_trip的前半段是不会计算在内的。\n\n如下图所示:\n\n[![](http://s5.51cto.com/wyfs02/M01/9C/79/wKioL1lwuj7QYAiwAABPkG0laHY133.jpg)](http://s5.51cto.com/wyfs02/M01/9C/79/wKioL1lwuj7QYAiwAABPkG0laHY133.jpg)\n\n当前只考虑网络时延，不考虑数据库和应用本身的时间消耗。\n\n**依据S2PL的性能优化**\n\n从上面的例子中,可以看出，需要把最热点的记录，放到事务最后，这样可以显著的提高吞吐量。更进一步:越热点记录离事务的终点越近(无论是commit还是rollback)\n\n笔者认为，先后顺序如下图:\n\n[![](http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwuk-R4qkXAAA7SDcppns985.png)](http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwuk-R4qkXAAA7SDcppns985.png)\n\n**避免死锁**\n\n这也是任何SQL加锁不可避免的。上文提到了按照记录Key的热度在事务中倒序排列。\n那么写代码的时候任何可能并发的SQL都必须按照这种顺序来处理，不然会造成死锁。如下图所示:\n\n[![](http://s1.51cto.com/wyfs02/M00/9C/79/wKiom1lwulyTw2NJAAAyulGqG34861.jpg)](http://s1.51cto.com/wyfs02/M00/9C/79/wKiom1lwulyTw2NJAAAyulGqG34861.jpg) \n\n**select for update和update where谓词计算**\n\n我们可以直接将一些简单的判断逻辑写到update的谓词里面，以减少加锁时间，考虑下面两种方案:\n\n方案1:\n\n [![](http://s2.51cto.com/wyfs02/M01/9C/79/wKiom1lwurTxzMLTAAByOdzp-VQ938.png)](http://s2.51cto.com/wyfs02/M01/9C/79/wKiom1lwurTxzMLTAAByOdzp-VQ938.png)\n\n方案2:\n\n[![](http://s2.51cto.com/wyfs02/M02/9C/79/wKiom1lwusOTX4_OAAA0ln26OdE506.png)](http://s2.51cto.com/wyfs02/M02/9C/79/wKiom1lwusOTX4_OAAA0ln26OdE506.png)\n\n如图所示:\n\n[![](http://s1.51cto.com/wyfs02/M00/9C/79/wKioL1lwumrhwj4SAABDZNCHCTk850.jpg)](http://s1.51cto.com/wyfs02/M00/9C/79/wKioL1lwumrhwj4SAABDZNCHCTk850.jpg)\n\n可以看到，通过在update中加谓词计算，少了1rt的时间。\n\n由于update在执行过程中对符合谓词条件的记录加的是和select for\nupdate一致的排它锁(具体的锁类型较为复杂，不在这里描述),所以两者效果一样。\n\n总结\n\nMySql采用两阶段加锁协议实现隔离性和一致性，我们只有深入的去理解这种协议，才能更好的对我们的SQL进行优化，增加系统的吞吐量.","source":"_posts/MySql两阶段加锁（2PL）协议剖析.md","raw":"---\ntitle: MySql两阶段加锁（2PL）协议剖析\ntags:\n  - 笔记\n  - 数据库\n  - MySQL\n  - 并发\noriginContent: \"（转）MySql两阶段加锁（2PL）协议剖析\\n------------------------------\\n\\n本文主要是讲述MySql(仅限innodb)的两阶段加锁(2PL)协议,而非两阶段提交(2PC)协议。\\n**前言**\\n\\n本文主要是讲述MySql(仅限innodb)的两阶段加锁(2PL)协议,而非两阶段提交(2PC)协议,区别如下:\\n\\n-   2PL,两阶段加锁协议:主要用于单机事务中的一致性与隔离性。\\n-   2PC,两阶段提交协议:主要用于分布式事务。\\n\\nMySql本身针对性能，还有一个MVCC(多版本控制)控制,本文不考虑此种技术，仅仅考虑MySql本身的加锁协议。\\n\\n**什么时候会加锁**\\n\\n在对记录更新操作或者(select for update、lock in share\\nmodel)时，会对记录加锁(有共享锁、排它锁、意向锁、gap锁、nextkey锁等等),本文为了简单考虑，不考虑锁的种类。\\n\\n**什么是两阶段加锁**\\n\\n在一个事务里面，分为加锁(lock)阶段和解锁(unlock)阶段,也即所有的lock操作都在unlock操作之前,如下图所示:\\n\\n[![](http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwugKB4awcAAAnfbnAG3o214.jpg-wh_651x-s_174240002.jpg)](http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwugKB4awcAAAnfbnAG3o214.jpg-wh_651x-s_174240002.jpg)\\n\\n**为什么需要两阶段加锁**\\n\\n引入2PL是为了保证事务的隔离性，即多个事务在并发的情况下等同于串行的执行。\\n在数学上证明了如下的封锁定理:\\n\\n如果事务是良构的且是两阶段的，那么任何一个合法的调度都是隔离的。\\n\\n具体的数学推到过程可以参照&lt;&lt;事务处理:概念与技术&gt;&gt;这本书的7.5.8.2节.\\n\\n此书乃是关于数据库事务的圣经，无需解释(中文翻译虽然晦涩，也能坚持读下去,强烈推荐)\\n\\n**工程实践中的两阶段加锁-S2PL**\\n\\n在实际情况下，SQL是千变万化、条数不定的,数据库很难在事务中判定什么是加锁阶段，什么是解锁阶段。于是引入了S2PL(Strict-2PL),即:\\n\\n在事务中只有提交(commit)或者回滚(rollback)时才是解锁阶段，其余时间为加锁阶段。\\n\\n如下图所示:\\n\\n[![](http://s3.51cto.com/wyfs02/M01/9C/79/wKiom1lwuhaRYo6tAAArQrdDeok245.jpg)](http://s3.51cto.com/wyfs02/M01/9C/79/wKiom1lwuhaRYo6tAAArQrdDeok245.jpg)\\n\\n这样的话，在实际的数据库中就很容易实现了。\\n\\n**两阶段加锁对性能的影响**\\n\\n上面很好的解释了两阶段加锁，现在我们分析下其对性能的影响。考虑下面两种不同的扣减库存的方案:\\n\\n[![](http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwu02RnfVLAAAtrhnPMvM342.jpg)](http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwu02RnfVLAAAtrhnPMvM342.jpg)\\n\\n[![](http://s5.51cto.com/wyfs02/M02/9C/79/wKioL1lwu1zC-atKAAAt2jSMCi0963.jpg)](http://s5.51cto.com/wyfs02/M02/9C/79/wKioL1lwu1zC-atKAAAt2jSMCi0963.jpg)\\n\\n由于在同一个事务之内，这几条对数据库的操作应该是等价的。但在两阶段加锁下的性能确是有比较大的差距。两者方案的时序如下图所示:\\n\\n[![](http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwujKi95pyAABND8qPNds262.jpg)](http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwujKi95pyAABND8qPNds262.jpg)\\n\\n由于库存往往是最重要的热点，是整个系统的瓶颈。那么如果采用第二种方案的话,tps应该理论上能够提升3rt/rt=3倍。这还仅仅是业务就只有三条SQL的情况下，多一条sql就多一次rt,就多一倍的时间。\\n\\n值得注意的是：\\n\\n在更新到数据库的那个时间点才算锁成功，提交到数据库的时候才算解锁成功，这两个round\\\\_trip的前半段是不会计算在内的。\\n\\n如下图所示:\\n\\n[![](http://s5.51cto.com/wyfs02/M01/9C/79/wKioL1lwuj7QYAiwAABPkG0laHY133.jpg)](http://s5.51cto.com/wyfs02/M01/9C/79/wKioL1lwuj7QYAiwAABPkG0laHY133.jpg)\\n\\n当前只考虑网络时延，不考虑数据库和应用本身的时间消耗。\\n\\n**依据S2PL的性能优化**\\n\\n从上面的例子中,可以看出，需要把最热点的记录，放到事务最后，这样可以显著的提高吞吐量。更进一步:越热点记录离事务的终点越近(无论是commit还是rollback)\\n\\n笔者认为，先后顺序如下图:\\n\\n[![](http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwuk-R4qkXAAA7SDcppns985.png)](http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwuk-R4qkXAAA7SDcppns985.png)\\n\\n**避免死锁**\\n\\n这也是任何SQL加锁不可避免的。上文提到了按照记录Key的热度在事务中倒序排列。\\n那么写代码的时候任何可能并发的SQL都必须按照这种顺序来处理，不然会造成死锁。如下图所示:\\n\\n[![](http://s1.51cto.com/wyfs02/M00/9C/79/wKiom1lwulyTw2NJAAAyulGqG34861.jpg)](http://s1.51cto.com/wyfs02/M00/9C/79/wKiom1lwulyTw2NJAAAyulGqG34861.jpg)\\_\\n\\n**select for update和update where谓词计算**\\n\\n我们可以直接将一些简单的判断逻辑写到update的谓词里面，以减少加锁时间，考虑下面两种方案:\\n\\n方案1:\\n\\n\\_[![](http://s2.51cto.com/wyfs02/M01/9C/79/wKiom1lwurTxzMLTAAByOdzp-VQ938.png)](http://s2.51cto.com/wyfs02/M01/9C/79/wKiom1lwurTxzMLTAAByOdzp-VQ938.png)\\n\\n方案2:\\n\\n[![](http://s2.51cto.com/wyfs02/M02/9C/79/wKiom1lwusOTX4_OAAA0ln26OdE506.png)](http://s2.51cto.com/wyfs02/M02/9C/79/wKiom1lwusOTX4_OAAA0ln26OdE506.png)\\n\\n如图所示:\\n\\n[![](http://s1.51cto.com/wyfs02/M00/9C/79/wKioL1lwumrhwj4SAABDZNCHCTk850.jpg)](http://s1.51cto.com/wyfs02/M00/9C/79/wKioL1lwumrhwj4SAABDZNCHCTk850.jpg)\\n\\n可以看到，通过在update中加谓词计算，少了1rt的时间。\\n\\n由于update在执行过程中对符合谓词条件的记录加的是和select for\\nupdate一致的排它锁(具体的锁类型较为复杂，不在这里描述),所以两者效果一样。\\n\\n总结\\n\\nMySql采用两阶段加锁协议实现隔离性和一致性，我们只有深入的去理解这种协议，才能更好的对我们的SQL进行优化，增加系统的吞吐量.\"\ncategories:\n  - 数据库\n  - 并发\ntoc: true\ndate: 2019-02-27 19:00:40\n---\n\n（转）MySql两阶段加锁（2PL）协议剖析\n------------------------------\n\n本文主要是讲述MySql(仅限innodb)的两阶段加锁(2PL)协议,而非两阶段提交(2PC)协议。\n**前言**\n\n本文主要是讲述MySql(仅限innodb)的两阶段加锁(2PL)协议,而非两阶段提交(2PC)协议,区别如下:\n\n-   2PL,两阶段加锁协议:主要用于单机事务中的一致性与隔离性。\n-   2PC,两阶段提交协议:主要用于分布式事务。\n\nMySql本身针对性能，还有一个MVCC(多版本控制)控制,本文不考虑此种技术，仅仅考虑MySql本身的加锁协议。\n<!-- more -->\n**什么时候会加锁**\n\n在对记录更新操作或者(select for update、lock in share\nmodel)时，会对记录加锁(有共享锁、排它锁、意向锁、gap锁、nextkey锁等等),本文为了简单考虑，不考虑锁的种类。\n\n**什么是两阶段加锁**\n\n在一个事务里面，分为加锁(lock)阶段和解锁(unlock)阶段,也即所有的lock操作都在unlock操作之前,如下图所示:\n\n[![](http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwugKB4awcAAAnfbnAG3o214.jpg-wh_651x-s_174240002.jpg)](http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwugKB4awcAAAnfbnAG3o214.jpg-wh_651x-s_174240002.jpg)\n\n**为什么需要两阶段加锁**\n\n引入2PL是为了保证事务的隔离性，即多个事务在并发的情况下等同于串行的执行。\n在数学上证明了如下的封锁定理:\n\n如果事务是良构的且是两阶段的，那么任何一个合法的调度都是隔离的。\n\n具体的数学推到过程可以参照&lt;&lt;事务处理:概念与技术&gt;&gt;这本书的7.5.8.2节.\n\n此书乃是关于数据库事务的圣经，无需解释(中文翻译虽然晦涩，也能坚持读下去,强烈推荐)\n\n**工程实践中的两阶段加锁-S2PL**\n\n在实际情况下，SQL是千变万化、条数不定的,数据库很难在事务中判定什么是加锁阶段，什么是解锁阶段。于是引入了S2PL(Strict-2PL),即:\n\n在事务中只有提交(commit)或者回滚(rollback)时才是解锁阶段，其余时间为加锁阶段。\n\n如下图所示:\n\n[![](http://s3.51cto.com/wyfs02/M01/9C/79/wKiom1lwuhaRYo6tAAArQrdDeok245.jpg)](http://s3.51cto.com/wyfs02/M01/9C/79/wKiom1lwuhaRYo6tAAArQrdDeok245.jpg)\n\n这样的话，在实际的数据库中就很容易实现了。\n\n**两阶段加锁对性能的影响**\n\n上面很好的解释了两阶段加锁，现在我们分析下其对性能的影响。考虑下面两种不同的扣减库存的方案:\n\n[![](http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwu02RnfVLAAAtrhnPMvM342.jpg)](http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwu02RnfVLAAAtrhnPMvM342.jpg)\n\n[![](http://s5.51cto.com/wyfs02/M02/9C/79/wKioL1lwu1zC-atKAAAt2jSMCi0963.jpg)](http://s5.51cto.com/wyfs02/M02/9C/79/wKioL1lwu1zC-atKAAAt2jSMCi0963.jpg)\n\n由于在同一个事务之内，这几条对数据库的操作应该是等价的。但在两阶段加锁下的性能确是有比较大的差距。两者方案的时序如下图所示:\n\n[![](http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwujKi95pyAABND8qPNds262.jpg)](http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwujKi95pyAABND8qPNds262.jpg)\n\n由于库存往往是最重要的热点，是整个系统的瓶颈。那么如果采用第二种方案的话,tps应该理论上能够提升3rt/rt=3倍。这还仅仅是业务就只有三条SQL的情况下，多一条sql就多一次rt,就多一倍的时间。\n\n值得注意的是：\n\n在更新到数据库的那个时间点才算锁成功，提交到数据库的时候才算解锁成功，这两个round\\_trip的前半段是不会计算在内的。\n\n如下图所示:\n\n[![](http://s5.51cto.com/wyfs02/M01/9C/79/wKioL1lwuj7QYAiwAABPkG0laHY133.jpg)](http://s5.51cto.com/wyfs02/M01/9C/79/wKioL1lwuj7QYAiwAABPkG0laHY133.jpg)\n\n当前只考虑网络时延，不考虑数据库和应用本身的时间消耗。\n\n**依据S2PL的性能优化**\n\n从上面的例子中,可以看出，需要把最热点的记录，放到事务最后，这样可以显著的提高吞吐量。更进一步:越热点记录离事务的终点越近(无论是commit还是rollback)\n\n笔者认为，先后顺序如下图:\n\n[![](http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwuk-R4qkXAAA7SDcppns985.png)](http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwuk-R4qkXAAA7SDcppns985.png)\n\n**避免死锁**\n\n这也是任何SQL加锁不可避免的。上文提到了按照记录Key的热度在事务中倒序排列。\n那么写代码的时候任何可能并发的SQL都必须按照这种顺序来处理，不然会造成死锁。如下图所示:\n\n[![](http://s1.51cto.com/wyfs02/M00/9C/79/wKiom1lwulyTw2NJAAAyulGqG34861.jpg)](http://s1.51cto.com/wyfs02/M00/9C/79/wKiom1lwulyTw2NJAAAyulGqG34861.jpg) \n\n**select for update和update where谓词计算**\n\n我们可以直接将一些简单的判断逻辑写到update的谓词里面，以减少加锁时间，考虑下面两种方案:\n\n方案1:\n\n [![](http://s2.51cto.com/wyfs02/M01/9C/79/wKiom1lwurTxzMLTAAByOdzp-VQ938.png)](http://s2.51cto.com/wyfs02/M01/9C/79/wKiom1lwurTxzMLTAAByOdzp-VQ938.png)\n\n方案2:\n\n[![](http://s2.51cto.com/wyfs02/M02/9C/79/wKiom1lwusOTX4_OAAA0ln26OdE506.png)](http://s2.51cto.com/wyfs02/M02/9C/79/wKiom1lwusOTX4_OAAA0ln26OdE506.png)\n\n如图所示:\n\n[![](http://s1.51cto.com/wyfs02/M00/9C/79/wKioL1lwumrhwj4SAABDZNCHCTk850.jpg)](http://s1.51cto.com/wyfs02/M00/9C/79/wKioL1lwumrhwj4SAABDZNCHCTk850.jpg)\n\n可以看到，通过在update中加谓词计算，少了1rt的时间。\n\n由于update在执行过程中对符合谓词条件的记录加的是和select for\nupdate一致的排它锁(具体的锁类型较为复杂，不在这里描述),所以两者效果一样。\n\n总结\n\nMySql采用两阶段加锁协议实现隔离性和一致性，我们只有深入的去理解这种协议，才能更好的对我们的SQL进行优化，增加系统的吞吐量.","slug":"MySql两阶段加锁（2PL）协议剖析","published":1,"updated":"2019-03-29T05:55:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22tga3x0005wurejjxq18il","content":"<h2 id=\"（转）MySql两阶段加锁（2PL）协议剖析\"><a href=\"#（转）MySql两阶段加锁（2PL）协议剖析\" class=\"headerlink\" title=\"（转）MySql两阶段加锁（2PL）协议剖析\"></a>（转）MySql两阶段加锁（2PL）协议剖析</h2><p>本文主要是讲述MySql(仅限innodb)的两阶段加锁(2PL)协议,而非两阶段提交(2PC)协议。<br><strong>前言</strong></p>\n<p>本文主要是讲述MySql(仅限innodb)的两阶段加锁(2PL)协议,而非两阶段提交(2PC)协议,区别如下:</p>\n<ul>\n<li>2PL,两阶段加锁协议:主要用于单机事务中的一致性与隔离性。</li>\n<li>2PC,两阶段提交协议:主要用于分布式事务。</li>\n</ul>\n<p>MySql本身针对性能，还有一个MVCC(多版本控制)控制,本文不考虑此种技术，仅仅考虑MySql本身的加锁协议。<br><a id=\"more\"></a><br><strong>什么时候会加锁</strong></p>\n<p>在对记录更新操作或者(select for update、lock in share<br>model)时，会对记录加锁(有共享锁、排它锁、意向锁、gap锁、nextkey锁等等),本文为了简单考虑，不考虑锁的种类。</p>\n<p><strong>什么是两阶段加锁</strong></p>\n<p>在一个事务里面，分为加锁(lock)阶段和解锁(unlock)阶段,也即所有的lock操作都在unlock操作之前,如下图所示:</p>\n<p><a href=\"http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwugKB4awcAAAnfbnAG3o214.jpg-wh_651x-s_174240002.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwugKB4awcAAAnfbnAG3o214.jpg-wh_651x-s_174240002.jpg\" alt=\"\"></a></p>\n<p><strong>为什么需要两阶段加锁</strong></p>\n<p>引入2PL是为了保证事务的隔离性，即多个事务在并发的情况下等同于串行的执行。<br>在数学上证明了如下的封锁定理:</p>\n<p>如果事务是良构的且是两阶段的，那么任何一个合法的调度都是隔离的。</p>\n<p>具体的数学推到过程可以参照&lt;&lt;事务处理:概念与技术&gt;&gt;这本书的7.5.8.2节.</p>\n<p>此书乃是关于数据库事务的圣经，无需解释(中文翻译虽然晦涩，也能坚持读下去,强烈推荐)</p>\n<p><strong>工程实践中的两阶段加锁-S2PL</strong></p>\n<p>在实际情况下，SQL是千变万化、条数不定的,数据库很难在事务中判定什么是加锁阶段，什么是解锁阶段。于是引入了S2PL(Strict-2PL),即:</p>\n<p>在事务中只有提交(commit)或者回滚(rollback)时才是解锁阶段，其余时间为加锁阶段。</p>\n<p>如下图所示:</p>\n<p><a href=\"http://s3.51cto.com/wyfs02/M01/9C/79/wKiom1lwuhaRYo6tAAArQrdDeok245.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s3.51cto.com/wyfs02/M01/9C/79/wKiom1lwuhaRYo6tAAArQrdDeok245.jpg\" alt=\"\"></a></p>\n<p>这样的话，在实际的数据库中就很容易实现了。</p>\n<p><strong>两阶段加锁对性能的影响</strong></p>\n<p>上面很好的解释了两阶段加锁，现在我们分析下其对性能的影响。考虑下面两种不同的扣减库存的方案:</p>\n<p><a href=\"http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwu02RnfVLAAAtrhnPMvM342.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwu02RnfVLAAAtrhnPMvM342.jpg\" alt=\"\"></a></p>\n<p><a href=\"http://s5.51cto.com/wyfs02/M02/9C/79/wKioL1lwu1zC-atKAAAt2jSMCi0963.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s5.51cto.com/wyfs02/M02/9C/79/wKioL1lwu1zC-atKAAAt2jSMCi0963.jpg\" alt=\"\"></a></p>\n<p>由于在同一个事务之内，这几条对数据库的操作应该是等价的。但在两阶段加锁下的性能确是有比较大的差距。两者方案的时序如下图所示:</p>\n<p><a href=\"http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwujKi95pyAABND8qPNds262.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwujKi95pyAABND8qPNds262.jpg\" alt=\"\"></a></p>\n<p>由于库存往往是最重要的热点，是整个系统的瓶颈。那么如果采用第二种方案的话,tps应该理论上能够提升3rt/rt=3倍。这还仅仅是业务就只有三条SQL的情况下，多一条sql就多一次rt,就多一倍的时间。</p>\n<p>值得注意的是：</p>\n<p>在更新到数据库的那个时间点才算锁成功，提交到数据库的时候才算解锁成功，这两个round_trip的前半段是不会计算在内的。</p>\n<p>如下图所示:</p>\n<p><a href=\"http://s5.51cto.com/wyfs02/M01/9C/79/wKioL1lwuj7QYAiwAABPkG0laHY133.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s5.51cto.com/wyfs02/M01/9C/79/wKioL1lwuj7QYAiwAABPkG0laHY133.jpg\" alt=\"\"></a></p>\n<p>当前只考虑网络时延，不考虑数据库和应用本身的时间消耗。</p>\n<p><strong>依据S2PL的性能优化</strong></p>\n<p>从上面的例子中,可以看出，需要把最热点的记录，放到事务最后，这样可以显著的提高吞吐量。更进一步:越热点记录离事务的终点越近(无论是commit还是rollback)</p>\n<p>笔者认为，先后顺序如下图:</p>\n<p><a href=\"http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwuk-R4qkXAAA7SDcppns985.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwuk-R4qkXAAA7SDcppns985.png\" alt=\"\"></a></p>\n<p><strong>避免死锁</strong></p>\n<p>这也是任何SQL加锁不可避免的。上文提到了按照记录Key的热度在事务中倒序排列。<br>那么写代码的时候任何可能并发的SQL都必须按照这种顺序来处理，不然会造成死锁。如下图所示:</p>\n<p><a href=\"http://s1.51cto.com/wyfs02/M00/9C/79/wKiom1lwulyTw2NJAAAyulGqG34861.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s1.51cto.com/wyfs02/M00/9C/79/wKiom1lwulyTw2NJAAAyulGqG34861.jpg\" alt=\"\"></a> </p>\n<p><strong>select for update和update where谓词计算</strong></p>\n<p>我们可以直接将一些简单的判断逻辑写到update的谓词里面，以减少加锁时间，考虑下面两种方案:</p>\n<p>方案1:</p>\n<p> <a href=\"http://s2.51cto.com/wyfs02/M01/9C/79/wKiom1lwurTxzMLTAAByOdzp-VQ938.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s2.51cto.com/wyfs02/M01/9C/79/wKiom1lwurTxzMLTAAByOdzp-VQ938.png\" alt=\"\"></a></p>\n<p>方案2:</p>\n<p><a href=\"http://s2.51cto.com/wyfs02/M02/9C/79/wKiom1lwusOTX4_OAAA0ln26OdE506.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s2.51cto.com/wyfs02/M02/9C/79/wKiom1lwusOTX4_OAAA0ln26OdE506.png\" alt=\"\"></a></p>\n<p>如图所示:</p>\n<p><a href=\"http://s1.51cto.com/wyfs02/M00/9C/79/wKioL1lwumrhwj4SAABDZNCHCTk850.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s1.51cto.com/wyfs02/M00/9C/79/wKioL1lwumrhwj4SAABDZNCHCTk850.jpg\" alt=\"\"></a></p>\n<p>可以看到，通过在update中加谓词计算，少了1rt的时间。</p>\n<p>由于update在执行过程中对符合谓词条件的记录加的是和select for<br>update一致的排它锁(具体的锁类型较为复杂，不在这里描述),所以两者效果一样。</p>\n<p>总结</p>\n<p>MySql采用两阶段加锁协议实现隔离性和一致性，我们只有深入的去理解这种协议，才能更好的对我们的SQL进行优化，增加系统的吞吐量.</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"（转）MySql两阶段加锁（2PL）协议剖析\"><a href=\"#（转）MySql两阶段加锁（2PL）协议剖析\" class=\"headerlink\" title=\"（转）MySql两阶段加锁（2PL）协议剖析\"></a>（转）MySql两阶段加锁（2PL）协议剖析</h2><p>本文主要是讲述MySql(仅限innodb)的两阶段加锁(2PL)协议,而非两阶段提交(2PC)协议。<br><strong>前言</strong></p>\n<p>本文主要是讲述MySql(仅限innodb)的两阶段加锁(2PL)协议,而非两阶段提交(2PC)协议,区别如下:</p>\n<ul>\n<li>2PL,两阶段加锁协议:主要用于单机事务中的一致性与隔离性。</li>\n<li>2PC,两阶段提交协议:主要用于分布式事务。</li>\n</ul>\n<p>MySql本身针对性能，还有一个MVCC(多版本控制)控制,本文不考虑此种技术，仅仅考虑MySql本身的加锁协议。<br>","more":"<br><strong>什么时候会加锁</strong></p>\n<p>在对记录更新操作或者(select for update、lock in share<br>model)时，会对记录加锁(有共享锁、排它锁、意向锁、gap锁、nextkey锁等等),本文为了简单考虑，不考虑锁的种类。</p>\n<p><strong>什么是两阶段加锁</strong></p>\n<p>在一个事务里面，分为加锁(lock)阶段和解锁(unlock)阶段,也即所有的lock操作都在unlock操作之前,如下图所示:</p>\n<p><a href=\"http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwugKB4awcAAAnfbnAG3o214.jpg-wh_651x-s_174240002.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwugKB4awcAAAnfbnAG3o214.jpg-wh_651x-s_174240002.jpg\" alt=\"\"></a></p>\n<p><strong>为什么需要两阶段加锁</strong></p>\n<p>引入2PL是为了保证事务的隔离性，即多个事务在并发的情况下等同于串行的执行。<br>在数学上证明了如下的封锁定理:</p>\n<p>如果事务是良构的且是两阶段的，那么任何一个合法的调度都是隔离的。</p>\n<p>具体的数学推到过程可以参照&lt;&lt;事务处理:概念与技术&gt;&gt;这本书的7.5.8.2节.</p>\n<p>此书乃是关于数据库事务的圣经，无需解释(中文翻译虽然晦涩，也能坚持读下去,强烈推荐)</p>\n<p><strong>工程实践中的两阶段加锁-S2PL</strong></p>\n<p>在实际情况下，SQL是千变万化、条数不定的,数据库很难在事务中判定什么是加锁阶段，什么是解锁阶段。于是引入了S2PL(Strict-2PL),即:</p>\n<p>在事务中只有提交(commit)或者回滚(rollback)时才是解锁阶段，其余时间为加锁阶段。</p>\n<p>如下图所示:</p>\n<p><a href=\"http://s3.51cto.com/wyfs02/M01/9C/79/wKiom1lwuhaRYo6tAAArQrdDeok245.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s3.51cto.com/wyfs02/M01/9C/79/wKiom1lwuhaRYo6tAAArQrdDeok245.jpg\" alt=\"\"></a></p>\n<p>这样的话，在实际的数据库中就很容易实现了。</p>\n<p><strong>两阶段加锁对性能的影响</strong></p>\n<p>上面很好的解释了两阶段加锁，现在我们分析下其对性能的影响。考虑下面两种不同的扣减库存的方案:</p>\n<p><a href=\"http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwu02RnfVLAAAtrhnPMvM342.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwu02RnfVLAAAtrhnPMvM342.jpg\" alt=\"\"></a></p>\n<p><a href=\"http://s5.51cto.com/wyfs02/M02/9C/79/wKioL1lwu1zC-atKAAAt2jSMCi0963.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s5.51cto.com/wyfs02/M02/9C/79/wKioL1lwu1zC-atKAAAt2jSMCi0963.jpg\" alt=\"\"></a></p>\n<p>由于在同一个事务之内，这几条对数据库的操作应该是等价的。但在两阶段加锁下的性能确是有比较大的差距。两者方案的时序如下图所示:</p>\n<p><a href=\"http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwujKi95pyAABND8qPNds262.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s2.51cto.com/wyfs02/M00/9C/79/wKioL1lwujKi95pyAABND8qPNds262.jpg\" alt=\"\"></a></p>\n<p>由于库存往往是最重要的热点，是整个系统的瓶颈。那么如果采用第二种方案的话,tps应该理论上能够提升3rt/rt=3倍。这还仅仅是业务就只有三条SQL的情况下，多一条sql就多一次rt,就多一倍的时间。</p>\n<p>值得注意的是：</p>\n<p>在更新到数据库的那个时间点才算锁成功，提交到数据库的时候才算解锁成功，这两个round_trip的前半段是不会计算在内的。</p>\n<p>如下图所示:</p>\n<p><a href=\"http://s5.51cto.com/wyfs02/M01/9C/79/wKioL1lwuj7QYAiwAABPkG0laHY133.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s5.51cto.com/wyfs02/M01/9C/79/wKioL1lwuj7QYAiwAABPkG0laHY133.jpg\" alt=\"\"></a></p>\n<p>当前只考虑网络时延，不考虑数据库和应用本身的时间消耗。</p>\n<p><strong>依据S2PL的性能优化</strong></p>\n<p>从上面的例子中,可以看出，需要把最热点的记录，放到事务最后，这样可以显著的提高吞吐量。更进一步:越热点记录离事务的终点越近(无论是commit还是rollback)</p>\n<p>笔者认为，先后顺序如下图:</p>\n<p><a href=\"http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwuk-R4qkXAAA7SDcppns985.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s4.51cto.com/wyfs02/M02/9C/79/wKiom1lwuk-R4qkXAAA7SDcppns985.png\" alt=\"\"></a></p>\n<p><strong>避免死锁</strong></p>\n<p>这也是任何SQL加锁不可避免的。上文提到了按照记录Key的热度在事务中倒序排列。<br>那么写代码的时候任何可能并发的SQL都必须按照这种顺序来处理，不然会造成死锁。如下图所示:</p>\n<p><a href=\"http://s1.51cto.com/wyfs02/M00/9C/79/wKiom1lwulyTw2NJAAAyulGqG34861.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s1.51cto.com/wyfs02/M00/9C/79/wKiom1lwulyTw2NJAAAyulGqG34861.jpg\" alt=\"\"></a> </p>\n<p><strong>select for update和update where谓词计算</strong></p>\n<p>我们可以直接将一些简单的判断逻辑写到update的谓词里面，以减少加锁时间，考虑下面两种方案:</p>\n<p>方案1:</p>\n<p> <a href=\"http://s2.51cto.com/wyfs02/M01/9C/79/wKiom1lwurTxzMLTAAByOdzp-VQ938.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s2.51cto.com/wyfs02/M01/9C/79/wKiom1lwurTxzMLTAAByOdzp-VQ938.png\" alt=\"\"></a></p>\n<p>方案2:</p>\n<p><a href=\"http://s2.51cto.com/wyfs02/M02/9C/79/wKiom1lwusOTX4_OAAA0ln26OdE506.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s2.51cto.com/wyfs02/M02/9C/79/wKiom1lwusOTX4_OAAA0ln26OdE506.png\" alt=\"\"></a></p>\n<p>如图所示:</p>\n<p><a href=\"http://s1.51cto.com/wyfs02/M00/9C/79/wKioL1lwumrhwj4SAABDZNCHCTk850.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s1.51cto.com/wyfs02/M00/9C/79/wKioL1lwumrhwj4SAABDZNCHCTk850.jpg\" alt=\"\"></a></p>\n<p>可以看到，通过在update中加谓词计算，少了1rt的时间。</p>\n<p>由于update在执行过程中对符合谓词条件的记录加的是和select for<br>update一致的排它锁(具体的锁类型较为复杂，不在这里描述),所以两者效果一样。</p>\n<p>总结</p>\n<p>MySql采用两阶段加锁协议实现隔离性和一致性，我们只有深入的去理解这种协议，才能更好的对我们的SQL进行优化，增加系统的吞吐量.</p>"},{"title":"siddhi源码","originContent":"","toc":false,"date":"2019-10-02T02:12:52.000Z","_content":"\n\n\n1. 不同的App互相不可见，那么我们的程序有多个App作用在同一个流该如何解决?\n> The stream processing constructs, such as streams and queries, defined within a Siddhi App is not visible even to the other Siddhi Apps running in the same JVM.\n\n2. 相同的流处理逻辑放在一个App中，通过内存接收器和内存源配置 \n> It is also recommended to move the repeated steam processing logics that exist in multiple Siddhi Applications, such as message retrieval and preprocessing, to a common Siddhi Application, whereby reducing code duplication and improving maintainability.\nIn this case, to pass the events from one Siddhi App to another, users can configure common topic using **In-Memory Sink** and **In-Memory Source** in order to communicate between them.\n3. **In-Memory Sink**\n4.playback是啥\n把数据上的时间戳当成current_time 时间流逝以时间戳为准，不以真实时间为准（存疑，参数问题）\n5. QueryCallback和StreamCallback区别？？\ntodo\n6. 如果不并发数据直接进入streamJunction \n7. Metrics:一款监控指标的度量类库\n8. receivers个数取决于？\n9. 异步情况下数据发送到dis\n![image.png](https://i.loli.net/2019/10/02/x95JpfEXqyDnecQ.png)\n![image.png](https://i.loli.net/2019/10/02/hNrOVY2XzUkt9DQ.png)","source":"_posts/siddhi源码.md","raw":"---\ntitle: siddhi源码\ntags: []\noriginContent: ''\ncategories: []\ntoc: false\ndate: 2019-10-02 10:12:52\n---\n\n\n\n1. 不同的App互相不可见，那么我们的程序有多个App作用在同一个流该如何解决?\n> The stream processing constructs, such as streams and queries, defined within a Siddhi App is not visible even to the other Siddhi Apps running in the same JVM.\n\n2. 相同的流处理逻辑放在一个App中，通过内存接收器和内存源配置 \n> It is also recommended to move the repeated steam processing logics that exist in multiple Siddhi Applications, such as message retrieval and preprocessing, to a common Siddhi Application, whereby reducing code duplication and improving maintainability.\nIn this case, to pass the events from one Siddhi App to another, users can configure common topic using **In-Memory Sink** and **In-Memory Source** in order to communicate between them.\n3. **In-Memory Sink**\n4.playback是啥\n把数据上的时间戳当成current_time 时间流逝以时间戳为准，不以真实时间为准（存疑，参数问题）\n5. QueryCallback和StreamCallback区别？？\ntodo\n6. 如果不并发数据直接进入streamJunction \n7. Metrics:一款监控指标的度量类库\n8. receivers个数取决于？\n9. 异步情况下数据发送到dis\n![image.png](https://i.loli.net/2019/10/02/x95JpfEXqyDnecQ.png)\n![image.png](https://i.loli.net/2019/10/02/hNrOVY2XzUkt9DQ.png)","slug":"siddhi源码","published":1,"updated":"2019-10-02T02:12:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22tga3z0006wureh2xqofcj","content":"<ol>\n<li><p>不同的App互相不可见，那么我们的程序有多个App作用在同一个流该如何解决?</p>\n<blockquote>\n<p>The stream processing constructs, such as streams and queries, defined within a Siddhi App is not visible even to the other Siddhi Apps running in the same JVM.</p>\n</blockquote>\n</li>\n<li><p>相同的流处理逻辑放在一个App中，通过内存接收器和内存源配置 </p>\n<blockquote>\n<p>It is also recommended to move the repeated steam processing logics that exist in multiple Siddhi Applications, such as message retrieval and preprocessing, to a common Siddhi Application, whereby reducing code duplication and improving maintainability.<br>In this case, to pass the events from one Siddhi App to another, users can configure common topic using <strong>In-Memory Sink</strong> and <strong>In-Memory Source</strong> in order to communicate between them.</p>\n</blockquote>\n</li>\n<li><strong>In-Memory Sink</strong><br>4.playback是啥<br>把数据上的时间戳当成current_time 时间流逝以时间戳为准，不以真实时间为准（存疑，参数问题）</li>\n<li>QueryCallback和StreamCallback区别？？<br>todo</li>\n<li>如果不并发数据直接进入streamJunction </li>\n<li>Metrics:一款监控指标的度量类库</li>\n<li>receivers个数取决于？</li>\n<li>异步情况下数据发送到dis<br><img src=\"https://i.loli.net/2019/10/02/x95JpfEXqyDnecQ.png\" alt=\"image.png\"><br><img src=\"https://i.loli.net/2019/10/02/hNrOVY2XzUkt9DQ.png\" alt=\"image.png\"></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>不同的App互相不可见，那么我们的程序有多个App作用在同一个流该如何解决?</p>\n<blockquote>\n<p>The stream processing constructs, such as streams and queries, defined within a Siddhi App is not visible even to the other Siddhi Apps running in the same JVM.</p>\n</blockquote>\n</li>\n<li><p>相同的流处理逻辑放在一个App中，通过内存接收器和内存源配置 </p>\n<blockquote>\n<p>It is also recommended to move the repeated steam processing logics that exist in multiple Siddhi Applications, such as message retrieval and preprocessing, to a common Siddhi Application, whereby reducing code duplication and improving maintainability.<br>In this case, to pass the events from one Siddhi App to another, users can configure common topic using <strong>In-Memory Sink</strong> and <strong>In-Memory Source</strong> in order to communicate between them.</p>\n</blockquote>\n</li>\n<li><strong>In-Memory Sink</strong><br>4.playback是啥<br>把数据上的时间戳当成current_time 时间流逝以时间戳为准，不以真实时间为准（存疑，参数问题）</li>\n<li>QueryCallback和StreamCallback区别？？<br>todo</li>\n<li>如果不并发数据直接进入streamJunction </li>\n<li>Metrics:一款监控指标的度量类库</li>\n<li>receivers个数取决于？</li>\n<li>异步情况下数据发送到dis<br><img src=\"https://i.loli.net/2019/10/02/x95JpfEXqyDnecQ.png\" alt=\"image.png\"><br><img src=\"https://i.loli.net/2019/10/02/hNrOVY2XzUkt9DQ.png\" alt=\"image.png\"></li>\n</ol>\n"},{"title":"(转)make 2>&1 | tee log.txt命令解析","originContent":"[原文](http://blog.sina.com.cn/s/blog_4b03202d0101e0xr.html)\nmake 2>&1 | tee log.txt命令解析\n\n\n1. make是什么？\n\nmake是linux下一个非常强大的命令，简单点就是你要编译你的源代码就得靠他了。\n\n2. 2>&1是什么意思？\n\n0 stdin，1 stdout，2 stderr\n\n2>&1应该分成两个部分来看，一个是2>以及另一个是&1，\n\n其中2>就是将标准出错重定向到某个特定的地方；&1是指无论标准输出在哪里。\n\n所以2>&1的意思就是说无论标准出错在哪里，都将标准出错重定向到标准输出中。\n\n\n\n有时候希望将错误的信息重新定向到输出，就是将2的结果重定向至1中就有了”2>1”这样的思路，如果按照上面的写法，系统会默认将错误的信息（STDERR）2重定向到一个名字为1的文件中，而非所想的（STDOUT）中。因此需要加&进行区分。就有了 2>&1 这样的用法\n\n\n\n3. | 管道\n\n管道的作用是提供一个通道，将上一个程序的标准输出重定向到下一个程序作为下一个程序的标准输入。\n\n通常使用管道的好处是一方面形式上简单，另一方面其执行效率要远高于使用临时文件。\n\n这里使用管道的目的是将make程序的输出重定向到下一个程序，其最终目的是用来将输出log存入文件中。\n\n4. tee是用来干什么的？\n\ntee从标准输入中读取，并将读入的内容写到标准输出以及文件中。\n\n所以这里tee命令的作用是将数据读入并写到标准输出以及log.txt中。","toc":false,"date":"2019-01-25T05:29:29.000Z","_content":"\n[原文](http://blog.sina.com.cn/s/blog_4b03202d0101e0xr.html)\nmake 2>&1 | tee log.txt命令解析\n\n\n1. make是什么？\n\nmake是linux下一个非常强大的命令，简单点就是你要编译你的源代码就得靠他了。\n\n2. 2>&1是什么意思？\n\n0 stdin，1 stdout，2 stderr\n\n2>&1应该分成两个部分来看，一个是2>以及另一个是&1，\n\n其中2>就是将标准出错重定向到某个特定的地方；&1是指无论标准输出在哪里。\n\n所以2>&1的意思就是说无论标准出错在哪里，都将标准出错重定向到标准输出中。\n\n<!-- more -->\n\n有时候希望将错误的信息重新定向到输出，就是将2的结果重定向至1中就有了”2>1”这样的思路，如果按照上面的写法，系统会默认将错误的信息（STDERR）2重定向到一个名字为1的文件中，而非所想的（STDOUT）中。因此需要加&进行区分。就有了 2>&1 这样的用法\n\n\n\n3. | 管道\n\n管道的作用是提供一个通道，将上一个程序的标准输出重定向到下一个程序作为下一个程序的标准输入。\n\n通常使用管道的好处是一方面形式上简单，另一方面其执行效率要远高于使用临时文件。\n\n这里使用管道的目的是将make程序的输出重定向到下一个程序，其最终目的是用来将输出log存入文件中。\n\n4. tee是用来干什么的？\n\ntee从标准输入中读取，并将读入的内容写到标准输出以及文件中。\n\n所以这里tee命令的作用是将数据读入并写到标准输出以及log.txt中。","source":"_posts/转-make-2-1-tee-log-txt命令解析.md","raw":"---\ntitle: (转)make 2>&1 | tee log.txt命令解析\ntags:\n  - 基础\n  - 笔记\n  - Linux\noriginContent: >-\n  [原文](http://blog.sina.com.cn/s/blog_4b03202d0101e0xr.html)\n\n  make 2>&1 | tee log.txt命令解析\n\n\n\n  1. make是什么？\n\n\n  make是linux下一个非常强大的命令，简单点就是你要编译你的源代码就得靠他了。\n\n\n  2. 2>&1是什么意思？\n\n\n  0 stdin，1 stdout，2 stderr\n\n\n  2>&1应该分成两个部分来看，一个是2>以及另一个是&1，\n\n\n  其中2>就是将标准出错重定向到某个特定的地方；&1是指无论标准输出在哪里。\n\n\n  所以2>&1的意思就是说无论标准出错在哪里，都将标准出错重定向到标准输出中。\n\n\n\n\n  有时候希望将错误的信息重新定向到输出，就是将2的结果重定向至1中就有了”2>1”这样的思路，如果按照上面的写法，系统会默认将错误的信息（STDERR）2重定向到一个名字为1的文件中，而非所想的（STDOUT）中。因此需要加&进行区分。就有了\n  2>&1 这样的用法\n\n\n\n\n  3. | 管道\n\n\n  管道的作用是提供一个通道，将上一个程序的标准输出重定向到下一个程序作为下一个程序的标准输入。\n\n\n  通常使用管道的好处是一方面形式上简单，另一方面其执行效率要远高于使用临时文件。\n\n\n  这里使用管道的目的是将make程序的输出重定向到下一个程序，其最终目的是用来将输出log存入文件中。\n\n\n  4. tee是用来干什么的？\n\n\n  tee从标准输入中读取，并将读入的内容写到标准输出以及文件中。\n\n\n  所以这里tee命令的作用是将数据读入并写到标准输出以及log.txt中。\ncategories:\n  - Linux\ntoc: false\ndate: 2019-01-25 13:29:29\n---\n\n[原文](http://blog.sina.com.cn/s/blog_4b03202d0101e0xr.html)\nmake 2>&1 | tee log.txt命令解析\n\n\n1. make是什么？\n\nmake是linux下一个非常强大的命令，简单点就是你要编译你的源代码就得靠他了。\n\n2. 2>&1是什么意思？\n\n0 stdin，1 stdout，2 stderr\n\n2>&1应该分成两个部分来看，一个是2>以及另一个是&1，\n\n其中2>就是将标准出错重定向到某个特定的地方；&1是指无论标准输出在哪里。\n\n所以2>&1的意思就是说无论标准出错在哪里，都将标准出错重定向到标准输出中。\n\n<!-- more -->\n\n有时候希望将错误的信息重新定向到输出，就是将2的结果重定向至1中就有了”2>1”这样的思路，如果按照上面的写法，系统会默认将错误的信息（STDERR）2重定向到一个名字为1的文件中，而非所想的（STDOUT）中。因此需要加&进行区分。就有了 2>&1 这样的用法\n\n\n\n3. | 管道\n\n管道的作用是提供一个通道，将上一个程序的标准输出重定向到下一个程序作为下一个程序的标准输入。\n\n通常使用管道的好处是一方面形式上简单，另一方面其执行效率要远高于使用临时文件。\n\n这里使用管道的目的是将make程序的输出重定向到下一个程序，其最终目的是用来将输出log存入文件中。\n\n4. tee是用来干什么的？\n\ntee从标准输入中读取，并将读入的内容写到标准输出以及文件中。\n\n所以这里tee命令的作用是将数据读入并写到标准输出以及log.txt中。","slug":"转-make-2-1-tee-log-txt命令解析","published":1,"updated":"2019-03-29T05:55:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22tga400009wurez44wz7vg","content":"<p><a href=\"http://blog.sina.com.cn/s/blog_4b03202d0101e0xr.html\" target=\"_blank\" rel=\"noopener\">原文</a><br>make 2&gt;&amp;1 | tee log.txt命令解析</p>\n<ol>\n<li>make是什么？</li>\n</ol>\n<p>make是linux下一个非常强大的命令，简单点就是你要编译你的源代码就得靠他了。</p>\n<ol start=\"2\">\n<li>2&gt;&amp;1是什么意思？</li>\n</ol>\n<p>0 stdin，1 stdout，2 stderr</p>\n<p>2&gt;&amp;1应该分成两个部分来看，一个是2&gt;以及另一个是&amp;1，</p>\n<p>其中2&gt;就是将标准出错重定向到某个特定的地方；&amp;1是指无论标准输出在哪里。</p>\n<p>所以2&gt;&amp;1的意思就是说无论标准出错在哪里，都将标准出错重定向到标准输出中。</p>\n<a id=\"more\"></a>\n<p>有时候希望将错误的信息重新定向到输出，就是将2的结果重定向至1中就有了”2&gt;1”这样的思路，如果按照上面的写法，系统会默认将错误的信息（STDERR）2重定向到一个名字为1的文件中，而非所想的（STDOUT）中。因此需要加&amp;进行区分。就有了 2&gt;&amp;1 这样的用法</p>\n<ol start=\"3\">\n<li>| 管道</li>\n</ol>\n<p>管道的作用是提供一个通道，将上一个程序的标准输出重定向到下一个程序作为下一个程序的标准输入。</p>\n<p>通常使用管道的好处是一方面形式上简单，另一方面其执行效率要远高于使用临时文件。</p>\n<p>这里使用管道的目的是将make程序的输出重定向到下一个程序，其最终目的是用来将输出log存入文件中。</p>\n<ol start=\"4\">\n<li>tee是用来干什么的？</li>\n</ol>\n<p>tee从标准输入中读取，并将读入的内容写到标准输出以及文件中。</p>\n<p>所以这里tee命令的作用是将数据读入并写到标准输出以及log.txt中。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"http://blog.sina.com.cn/s/blog_4b03202d0101e0xr.html\" target=\"_blank\" rel=\"noopener\">原文</a><br>make 2&gt;&amp;1 | tee log.txt命令解析</p>\n<ol>\n<li>make是什么？</li>\n</ol>\n<p>make是linux下一个非常强大的命令，简单点就是你要编译你的源代码就得靠他了。</p>\n<ol start=\"2\">\n<li>2&gt;&amp;1是什么意思？</li>\n</ol>\n<p>0 stdin，1 stdout，2 stderr</p>\n<p>2&gt;&amp;1应该分成两个部分来看，一个是2&gt;以及另一个是&amp;1，</p>\n<p>其中2&gt;就是将标准出错重定向到某个特定的地方；&amp;1是指无论标准输出在哪里。</p>\n<p>所以2&gt;&amp;1的意思就是说无论标准出错在哪里，都将标准出错重定向到标准输出中。</p>","more":"<p>有时候希望将错误的信息重新定向到输出，就是将2的结果重定向至1中就有了”2&gt;1”这样的思路，如果按照上面的写法，系统会默认将错误的信息（STDERR）2重定向到一个名字为1的文件中，而非所想的（STDOUT）中。因此需要加&amp;进行区分。就有了 2&gt;&amp;1 这样的用法</p>\n<ol start=\"3\">\n<li>| 管道</li>\n</ol>\n<p>管道的作用是提供一个通道，将上一个程序的标准输出重定向到下一个程序作为下一个程序的标准输入。</p>\n<p>通常使用管道的好处是一方面形式上简单，另一方面其执行效率要远高于使用临时文件。</p>\n<p>这里使用管道的目的是将make程序的输出重定向到下一个程序，其最终目的是用来将输出log存入文件中。</p>\n<ol start=\"4\">\n<li>tee是用来干什么的？</li>\n</ol>\n<p>tee从标准输入中读取，并将读入的内容写到标准输出以及文件中。</p>\n<p>所以这里tee命令的作用是将数据读入并写到标准输出以及log.txt中。</p>"},{"title":"(转)基于 Token 的身份验证：JSON Web Token","originContent":"[基于 Token 的身份验证：JSON Web Token](https://ninghao.net/blog/2834)","toc":false,"date":"2019-01-23T09:21:44.000Z","_content":"\n[基于 Token 的身份验证：JSON Web Token](https://ninghao.net/blog/2834)","source":"_posts/转-基于-Token-的身份验证：JSON-Web-Token.md","raw":"---\ntitle: (转)基于 Token 的身份验证：JSON Web Token\ntags:\n  - Web\n  - 安全\noriginContent: '[基于 Token 的身份验证：JSON Web Token](https://ninghao.net/blog/2834)'\ncategories:\n  - Web\n  - 安全\ntoc: false\ndate: 2019-01-23 17:21:44\n---\n\n[基于 Token 的身份验证：JSON Web Token](https://ninghao.net/blog/2834)","slug":"转-基于-Token-的身份验证：JSON-Web-Token","published":1,"updated":"2019-01-23T09:22:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22tga41000awure91bmqp2q","content":"<p><a href=\"https://ninghao.net/blog/2834\" target=\"_blank\" rel=\"noopener\">基于 Token 的身份验证：JSON Web Token</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://ninghao.net/blog/2834\" target=\"_blank\" rel=\"noopener\">基于 Token 的身份验证：JSON Web Token</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck22tga3q0000wurep415xqcn","category_id":"ck22tga3v0002wureh4fxqu0n","_id":"ck22tga41000bwure0gxtn17w"},{"post_id":"ck22tga3t0001wurerdso400b","category_id":"ck22tga3z0007wure7iph3s92","_id":"ck22tga43000fwurea099bbun"},{"post_id":"ck22tga3w0004wureciai2046","category_id":"ck22tga3z0007wure7iph3s92","_id":"ck22tga44000iwuresqakhfis"},{"post_id":"ck22tga400009wurez44wz7vg","category_id":"ck22tga44000kwurejmlpbtic","_id":"ck22tga45000pwure59039v1i"},{"post_id":"ck22tga3x0005wurejjxq18il","category_id":"ck22tga43000ewurebqxhd04u","_id":"ck22tga47000wwurefm5wuxvs"},{"post_id":"ck22tga3x0005wurejjxq18il","category_id":"ck22tga45000qwurepvxf8dxw","_id":"ck22tga47000zwureu2aizmpd"},{"post_id":"ck22tga41000awure91bmqp2q","category_id":"ck22tga45000nwure2hibahu0","_id":"ck22tga470012wurehv199vtk"},{"post_id":"ck22tga41000awure91bmqp2q","category_id":"ck22tga46000swure1w0wmtg4","_id":"ck22tga480013wure3maxri45"}],"PostTag":[{"post_id":"ck22tga3q0000wurep415xqcn","tag_id":"ck22tga3w0003wureqfb24a9d","_id":"ck22tga44000hwure5nl4oedg"},{"post_id":"ck22tga3q0000wurep415xqcn","tag_id":"ck22tga3z0008wurejovjppqz","_id":"ck22tga44000jwuregg9hdohs"},{"post_id":"ck22tga3q0000wurep415xqcn","tag_id":"ck22tga42000dwure0z01ayp9","_id":"ck22tga44000mwurepcd51a27"},{"post_id":"ck22tga3t0001wurerdso400b","tag_id":"ck22tga43000gwurel46twved","_id":"ck22tga46000uwure5f1o8cvu"},{"post_id":"ck22tga3t0001wurerdso400b","tag_id":"ck22tga44000lwurevpd3vhfh","_id":"ck22tga47000vwurebe5xibal"},{"post_id":"ck22tga3t0001wurerdso400b","tag_id":"ck22tga45000owurewy9z3v1c","_id":"ck22tga47000ywure7h6yjckn"},{"post_id":"ck22tga3t0001wurerdso400b","tag_id":"ck22tga3w0003wureqfb24a9d","_id":"ck22tga470010wurewl3j85u5"},{"post_id":"ck22tga3w0004wureciai2046","tag_id":"ck22tga43000gwurel46twved","_id":"ck22tga490016wureu3xkbxf4"},{"post_id":"ck22tga3w0004wureciai2046","tag_id":"ck22tga44000lwurevpd3vhfh","_id":"ck22tga490017wuresrpzyv94"},{"post_id":"ck22tga3w0004wureciai2046","tag_id":"ck22tga45000owurewy9z3v1c","_id":"ck22tga490019wuremjl0075v"},{"post_id":"ck22tga3w0004wureciai2046","tag_id":"ck22tga3w0003wureqfb24a9d","_id":"ck22tga49001awure9cvz8okx"},{"post_id":"ck22tga3x0005wurejjxq18il","tag_id":"ck22tga3w0003wureqfb24a9d","_id":"ck22tga4a001dwurehpb5p4y9"},{"post_id":"ck22tga3x0005wurejjxq18il","tag_id":"ck22tga480015wureo3pbo5yy","_id":"ck22tga4a001ewure79bal636"},{"post_id":"ck22tga3x0005wurejjxq18il","tag_id":"ck22tga490018wurei6vhbzl3","_id":"ck22tga4a001gwurejth7mfzm"},{"post_id":"ck22tga3x0005wurejjxq18il","tag_id":"ck22tga49001bwure6ey77ja6","_id":"ck22tga4b001hwurefp9weyvx"},{"post_id":"ck22tga400009wurez44wz7vg","tag_id":"ck22tga44000lwurevpd3vhfh","_id":"ck22tga4b001jwureuk06pkhf"},{"post_id":"ck22tga400009wurez44wz7vg","tag_id":"ck22tga3w0003wureqfb24a9d","_id":"ck22tga4b001kwure7d9411kf"},{"post_id":"ck22tga400009wurez44wz7vg","tag_id":"ck22tga4a001fwurefb8ed5pt","_id":"ck22tga4b001mwurelqcblqem"},{"post_id":"ck22tga41000awure91bmqp2q","tag_id":"ck22tga4b001iwurehmk6wviu","_id":"ck22tga4c001nwurek1xub8gg"},{"post_id":"ck22tga41000awure91bmqp2q","tag_id":"ck22tga4b001lwureg2qb6nwf","_id":"ck22tga4c001owurenwffy9yu"}],"Tag":[{"name":"笔记","_id":"ck22tga3w0003wureqfb24a9d"},{"name":"算法","_id":"ck22tga3z0008wurejovjppqz"},{"name":"动态规划","_id":"ck22tga42000dwure0z01ayp9"},{"name":"语言","_id":"ck22tga43000gwurel46twved"},{"name":"基础","_id":"ck22tga44000lwurevpd3vhfh"},{"name":"Java","_id":"ck22tga45000owurewy9z3v1c"},{"name":"数据库","_id":"ck22tga480015wureo3pbo5yy"},{"name":"MySQL","_id":"ck22tga490018wurei6vhbzl3"},{"name":"并发","_id":"ck22tga49001bwure6ey77ja6"},{"name":"Linux","_id":"ck22tga4a001fwurefb8ed5pt"},{"name":"Web","_id":"ck22tga4b001iwurehmk6wviu"},{"name":"安全","_id":"ck22tga4b001lwureg2qb6nwf"}]}}